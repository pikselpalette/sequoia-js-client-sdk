<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"session.js.html":{"id":"session.js.html","title":"Source: session.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: session.js import delay from 'lodash.delay'; import differenceInMilliseconds from 'date-fns/difference_in_milliseconds'; export const NO_OAUTH_SECRET_PROVIDED = ` No oAuth client secret was provided. Provide a base64 secret to allow oAuth logins. `; /** * Manages the end user authentication session against (currently) pauth token. * * &lt;p&gt;This class is not intended to be used directly. You should instead use {@link Client#login}, * {@link Client#logout} and [Client's session property]{@link Client}&lt;/p&gt; * * &lt;p&gt;See the {@link https://identity-reference.sequoia.piksel.com/docs|Sequoia Documentation} for more information.&lt;/p&gt; * * @param {Transport} transport - Transport instance to use for fetching * @param {string} directory - The directory (sometimes refered to as 'domain') that the user belongs to. * This is prepended to the username on login requests (POSTs to /pauth/token) * @param {Registry} registry - a stored registry reference to query * @param {string?} identityUri - The endpoint URI for the sequoia identity service e.g. https://identity-sandbox.sequoia.piksel.com * * @property {string} directory - Stored from the initial `directory` parameter * @property {string?} identityUri - Stored from the initial `identityUri` parameter * @property {string?} token - The access_token returned from the call to * {@link https://identity-reference.sequoia.piksel.com/docs/routes/pauth-token|/pauth/token} after logging in * @property {Object[]} tenants - Stored array of tenants the user has access to * See the {@link https://identity-reference.sequoia.piksel.com/docs/routes/pauth-tenants|tenants documentation} for more information. * @property {Object} access - Stored access information for the logged in user. * See the {@link https://identity-reference.sequoia.piksel.com/docs/routes/pauth-access|access documentation} for more information. * * @example * import Session from '@pikselpalette/sequoia-js-client-sdk/lib/session'; * * const session = new Session('piksel', 'https://identity-sandbox.sequoia.piksel.com'); * session.authenticateWithCredentials('username', 'password').then((session) =&gt; this.registry.fetch(session.currentOwner())).then(() =&gt; this.session) * */ class Session { constructor(transport, directory, registry, identityUri) { this.transport = transport; this.directory = directory; this.registry = registry; this.identityUri = identityUri; this.token = null; this.tenants = []; this.access = {}; this.currentTenantName = null; this.token = null; this.expiryWarningRef = null; } getIdentityUri() { const identityUri = this.registry.getServiceLocation('identity'); if (identityUri !== null) { this.identityUri = identityUri; } // We either had the identityUri supplied via the `client` constructor // or we had a pre-populated registry, so return it if (this.identityUri) { return Promise.resolve(this.identityUri); } // We don't know about the location of identity, so ask the registry const tenancy = this.currentTenant ? this.currentTenant.name : this.directory; return this.registry.fetch(tenancy).then(() =&gt; { this.identityUri = this.registry.getServiceLocation('identity'); }); } /** * @typedef {Object} AuthenticationOptions * @property {string?} strategy - 'pauth' or 'oauth' * @property {string?} secret - [base64 clientId and clientSecret]{@link https://identity-euw1shared.sequoia.piksel.com/docs/groups/oauth} * @property {string?} url - Override the URL to hit for authentication. Useful * for providing custom endpoints to provide an access_token */ /** * Create a session based on end user credentials * * @param {string?} username * @param {string?} password * @param {AuthenticationOptions?} options * * @see {Client#login} * @returns {Promise} */ authenticateWithCredentials(username, password, options = { strategy: 'pauth' }) { return this.getIdentityUri().then(() =&gt; { const { strategy, url, secret } = options; let endpoint = `${this.identityUri}/pauth/token`; let body = JSON.stringify({ username: `${this.directory}\\\\${username}`, password }); let headers; if (strategy === 'oauth') { if (secret === undefined) { return Promise.reject(NO_OAUTH_SECRET_PROVIDED); } endpoint = `${this.identityUri}/oauth/token`; if (typeof username === 'string' &amp;&amp; typeof password === 'string') { body = `grant_type=password&amp;username=${this.directory}\\\\${username}&amp;password=${encodeURIComponent(password)}`; } else { body = 'grant_type=client_credentials'; } headers = { authorization: `Basic ${secret}`, 'Content-Type': 'application/x-www-form-urlencoded' }; } // The `url` option overrides if (url) { endpoint = url; } delete options.url; delete options.strategy; delete options.secret; const fetchOptions = { body }; // Just { body, headers } leaves options.headers as undefined and therefor // overrides the defaults in transport.js if (headers) { fetchOptions.headers = headers; } return ( this.transport .post(endpoint, Object.assign({}, fetchOptions, options)) // eslint-disable-next-line camelcase .then(({ access_token }) =&gt; this.authenticateWithToken(access_token)) .then(() =&gt; this) ); }); } /** * Create a session based on an existing bearer token * * Use this if you acquire an access token via other means, * i.e. an existing oauth mechanism for Sequoia * * @param {string} token * * @returns {Promise} */ authenticateWithToken(token) { if (token) { this.token = token; this.transport.defaults.headers.authorization = `Bearer ${this.token}`; } this.clearExpiryWarning(); return this.populateTenants() .then(() =&gt; this.populateAccess()) .then(() =&gt; { this.startOnExpiryWarningTimer(); return this; }); } /** * Set the expiry warning callback and threshold. * @param {Function?} callback Callback invoked when token is expiring * @param {Number?} threshold Threshold before expiry on which to invoke the callback, default 60000ms */ setOnExpiryWarning(callback, threshold = 60000) { this.clearExpiryWarning(); if (callback) { this.onExpiryWarning = callback; this.expiryThreshold = threshold; } this.startOnExpiryWarningTimer(); } /** * Clear the expiry warning callback and cancel any timers. */ clearExpiryWarning() { this.onExpiryWarning = null; this.expiryThreshold = null; // Clear any existing timers if (this.expiryWarningRef) { clearTimeout(this.expiryWarningRef); this.expiryWarningRef = null; } } /** * Start the expiry warning timer. */ startOnExpiryWarningTimer() { if (this.access &amp;&amp; this.onExpiryWarning) { const expiryWarning = differenceInMilliseconds(this.access.expiresAt, new Date()) - this.expiryThreshold; this.expiryWarningRef = delay(expiringAccess =&gt; this.tokenExpiring(expiringAccess), expiryWarning, this.access); } } /** * Called when the token is about to expire. * Calls the callback if registered. * @param {AccessSession} access The Sequoia access session */ tokenExpiring(access) { if (this.onExpiryWarning) { this.onExpiryWarning(access); } } /** * Populate the `tenants` properties of `Session` with * data returned from Sequoia. * * @private * * @returns {Promise} */ populateTenants() { if (this.token === null) { // Not authenticated, so do nothing return Promise.resolve(); } return this.getIdentityUri() .then(() =&gt; this.transport.get(`${this.identityUri}/pauth/tenants`)) .then((json) =&gt; { this.tenants = json.tenants; }); } /** * Populate the `access` properties of `Session` with * data returned from Sequoia. * * @private * * @returns {Promise} */ populateAccess() { if (this.token === null) { // Not authenticated, so do nothing return Promise.resolve(); } return this.getIdentityUri() .then(() =&gt; { let accessUri = `${this.identityUri}/pauth/access`; if (this.currentOwner()) { accessUri = `${accessUri}?tenants=${this.currentOwner()}`; } return this.transport.get(accessUri); }) .then((json) =&gt; { this.access = json; }); } /** * Returns whether there is a currently active logged in session * * @returns {boolean} */ isActive() { return this.token !== null; } /** * Find a tenant by name in the current set of user available tenants * * @returns {Object} */ findTenant(tenantName) { return this.tenants.find(item =&gt; item.name === tenantName); } /** * The current tenant being used in this session. * * When getting this propery, it will default to the first tenant in the {@link Session.tenants} array * if this property has not been explicitly set * * Will return null if there are no tenants available (e.g. the session is inactive) * @type {string?} */ get currentTenant() { if (!this.tenants.length) { return null; } return this.currentTenantName === null ? this.tenants[0] : this.findTenant(this.currentTenantName); } set currentTenant(tenantName) { this.currentTenantName = tenantName; } /** * Get the name (owner) of the current tenant * * @returns {string} */ currentOwner() { return this.currentTenant ? this.currentTenant.name : this.currentTenantName; } /** * Log out an end user * * @todo Should this make a call to some service to revoke the auth token? * * @returns {Session} */ destroy() { this.token = null; this.tenants = []; this.access = {}; this.currentTenantName = null; delete this.transport.defaults.headers.Authorization; if (this.expiryWarningRef) { clearTimeout(this.expiryWarningRef); this.expiryWarningRef = null; } return this; } } export default Session; × Search results Close "},"business_endpoint.js.html":{"id":"business_endpoint.js.html","title":"Source: business_endpoint.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: business_endpoint.js import queryString from 'query-string'; import Query from './query'; export function InvalidCriteriaException(message) { this.message = message; this.name = 'InvalidCriteriaException'; } /** * BusinessEndpoint is the main interaction class against non-resourceful sequoia endpoints. * * Business endpoints are simple rest-like endpoints. Due to the nature of them, this SDK * is not (currently) intending to provide anything other than simple validation for * paths and query strings. Objects are just the plain JSON returned from the service, * unlike {@link ResourcefulEndpoint} which will send back {@link ResourceCollection} and * {@link Resource}s. * * This class should not be used directly, but should instead be obtained * from {@link Service#businessEndpoint} * * @param {Transport} transport - Transport instance to use for fetching * @param {Object} business - JSON object describing this business endpoint * (fetched from sequoia services 'descriptor') * * @example * // `contents` is used in the rest of the examples as our reference * // to a ResourcefulEndpoint * let feeds; * * client.generate().then(() =&gt; { * client.service('feed').then((service) =&gt; { * // Get a business endpoint (this is synchronous as the service passed * // all the necessary data): * feeds = service.businessEndpoint('feeds', { name: 'UTV-15246' }); * // whatever * }); * }); * * @private */ class BusinessEndpoint { constructor(transport, endpoint, pathOptions) { this.transport = transport; this.endpoint = endpoint; let { path } = endpoint; const errors = []; const pathParams = Object.assign({ owner: endpoint.tenant }, pathOptions); (path.match(/([^{]*?).(?=\\})/gim) || []).forEach((pathParam) =&gt; { if (!(pathParam in pathParams) &amp;&amp; !pathParam.endsWith('?')) { errors.push(`Required path parameter '${pathParam}' was not supplied`); } }); if (errors.length) { throw new Error(errors.join('\\n')); } Object.keys(pathParams).forEach((key) =&gt; { path = path.replace(new RegExp(`{${key}[?]?}`), pathParams[key]); }); // Strip out any optional params: path = path.replace(/{[^?]+\\?}/g, ''); this.endpoint.location = `${this.endpoint.location}${path}`; } /** * Perform an action against the business endpoint. Note, the HTTP method comes from * the `routes['name'].method` portion of the descriptor * * @param {(string|Query)} criteria - A query string to append to the request * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Transport#fetchWithDefaults} * * @throws InvalidCriteriaException * * @returns {Promise} - JSON returned from the endpoint */ fetch(criteria, options) { const { method } = this.endpoint; const fetchOptions = Object.assign({ method }, options); return this.transport.fetchWithDefaults(this.endPointUrl(criteria), fetchOptions); } /** * Required query parameters for the business endpoint from the * `routes['name'].inputs.query` portion of the descriptor * * Returns the raw objects * * @example * // Returns e.g. * [{ * &quot;type&quot;: &quot;name&quot;, * &quot;meta&quot;: [{ * &quot;sequoiaType&quot;: &quot;name&quot; * }], * &quot;invalids&quot;: [&quot;&quot; ], * &quot;name&quot;: &quot;count&quot;, * &quot;required&quot;: false * }, * { * &quot;type&quot;: &quot;string&quot;, * &quot;description&quot;: &quot;language to localise response to&quot;, * &quot;invalids&quot;: [&quot;&quot;], * &quot;name&quot;: &quot;lang&quot;, * &quot;required&quot;: false * }] * * @type {object[]} */ get requiredQueryParameters() { const { inputs } = this.endpoint; if (inputs &amp;&amp; inputs.query) { return inputs.query.filter(query =&gt; query.required === true); } return []; } /** * Returns an array of query parameter names * * @example * // Returns e.g. * ['currency', 'price'] * * @type {string[]} */ get requiredQueryParameterNames() { return this.requiredQueryParameters.map(q =&gt; q.name); } // Private methods /** * Return a query string to append to the HTTP call. Will default to appending * `?owner=&lt;owner&gt;` * * @param {(string|Query)?} criteria - A (potential) query string to append to the request * * @private * * @throws InvalidCriteriaException * * @returns {string} */ criteriaToQuery(criteria) { let query = ''; if (typeof criteria === 'string') { if (criteria !== '') { query += `?${criteria}`; } } else if (criteria instanceof Query) { query += `?${criteria.toQueryString()}`; } const requestQueryParams = Object.keys(queryString.parse(query)); this.requiredQueryParameterNames.forEach((requiredValue) =&gt; { if (!requestQueryParams.includes(requiredValue)) { throw new InvalidCriteriaException(`Required query parameter '${requiredValue}' was not passed`); } }); return query; } /** * Get the full URL to the business endpoint/item we will send the request to * * @param {(string|Query)?} criteria - A (potential) query string to append to the request * * @see {@link BusinessEndpoint#criteriaToQuery} * * @private * * @throws InvalidCriteriaException * * @returns {string} */ endPointUrl(criteria) { return `${this.endpoint.location}${this.criteriaToQuery(criteria)}`; } } export default BusinessEndpoint; × Search results Close "},"client.js.html":{"id":"client.js.html","title":"Source: client.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: client.js import Transport from './transport.js'; import Session from './session.js'; import Registry from './registry.js'; import { where, field, param, textSearch } from './query.js'; /** * @typedef {Object} ClientOptions * Options for the Client. * @property {string} directory - The directory to pass through to {@link Session}. * @property {string} registryUri - The registryUri to pass through to {@link Registry}. * @property {string?} identityUri - Optional identityUri to pass through to {@link Session}. */ /** * Provides initial setup and subsequent access to the SDK * * @param {ClientOptions} options - Options for the Client. * * @property {Transport} transport - a stored transport instance used for fetching * @property {Session} session - a stored session to query the current users' authentication state with * @property {Registry} registry - a stored registry reference to query * * @requires {@link Transport} * @requires {@link Session} * @requires {@link Registry} * * @tutorial getting_started * * @example * * import Client from '@pikselpalette/sequoia-js-client-sdk/lib/client'; * import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; * * // Create a client: * const client = new Client({ directory: 'piksel', * registry: 'https://registry-sandbox.sequoia.piksel.com' }); * * client.login('username', 'password').then(session =&gt; { * // You can now query the session provided as the first argument (or * // client.session); e.g. `session.isActive()` * * // Get a service:: * client.service('metadata').then(service =&gt; { * // Get a resourceful endpoint (this is synchronous as the service passed * // all the necessary data): * const contents = service.resourcefulEndpoint('contents'); * * contents.browse(where().fields('title', 'mediumSynopsis','duration', 'ref') * .include('assets').page(1).perPage(24).orderByUpdatedAt().desc().count()) * .then(json =&gt; { * // Do something with the json returned * }); * }); * }).catch(error =&gt; { * // Not logged in, inspect `error` to see why * }); * * @example * * // Adding a tenant argument to the Client means you can skip setting the tenant later on. * const client = new Client({ directory: 'piksel', * registry: 'https://registry-sandbox.sequoia.piksel.com', * tenant: 'demo' }); * * @example * * // Adding a token argument to the Client means you do not need to call generate() * // in a separate step. * const client = new Client({ directory: 'piksel', * registry: 'https://registry-sandbox.sequoia.piksel.com', * token: 'yourGeneratedToken' }); */ class Client { constructor({ directory, registryUri, identityUri, token, tenant }) { this.transport = new Transport(); this.registry = new Registry(this.transport, registryUri); this.session = new Session(this.transport, directory, this.registry, identityUri); if (tenant) this.setTenancy(tenant); if (token) this.generate(token); } /** * Get a {@link Service} from the {@link Registry} * * @see {@link Registry#getService} * * @returns {Promise} */ service(serviceName) { return this.registry.getService(serviceName); } /** * Log an end user in with username and password credentials * * @param {string?} username - the end user's username * @param {string?} password - the end user's password * @param {AuthenticationOptions?} options * * @example * // Standard 'pauth' login * client.login('test_username', 'test_password').then((session) =&gt; { * // Do something with the session * }); * * // 'pauth' style login to a custom endpoint * client.login('test_username', 'test_password', { * url: 'https://example.com/custom/pauth' * }).then((session) =&gt; { * // Custom url should return a json response of { 'access_token': &lt;token&gt; } * // Do something with the session * }); * @example * // Standard 'oauth' login (password grant) * const secret = 'somebase64secret=='; * client.login('test_username', 'test_password', { * strategy: 'oauth', * secret * }).then((session) =&gt; { * // Do something with the session * }); * * @example * // Client oauth (client credentials grant) * const secret = 'somebase64secret=='; * client.login(null, null, { * strategy: 'oauth', * secret * }).then((session) =&gt; { * // Do something with the session * }); * * @example * // login will reject when not passing a secret * client.login('test_username', 'test_password', { * strategy: 'oauth' * }).catch((err) =&gt; { * // Inspect `err` * }); * * @see {Session#authenticateWithCredentials} * * @returns {Promise} - First argument to the resolved Promise is the {@link Session} object that * has been updatedc */ login(username, password, options = { strategy: 'pauth' }) { return this.session .authenticateWithCredentials(username, password, options) .then(session =&gt; this.registry.fetch(session.currentOwner())) .then(() =&gt; this.session); } /** * Generate a Session from an existing bearer token. * * It is also useful to use this if you acquire an access token via other means, * i.e. an existing oauth mechanism for Sequoia * * Call this method without a token parameter to instantiate the client for anonymous * usage. Note: currently the Sequoia registry does not provide anonymous access. * See the below example for how to handle this currently. * * @param {string?} token - an existing bearer token for an end user * * @example * client.generate('some token').then(doSomething); * * @example * // Anonymous usage: * client.generate().catch((err) =&gt; { * if (err.response &amp;&amp; err.response.status === 401) { * client.registry.tenant = SQ_DIRECTORY; * * client.registry.services.push({ * owner: 'root', * name: 'identity', * title: 'Identity Service', * location: SQ_IDENTITY_URL * }); * * client.registry.services.push({ * owner: 'root', * name: 'gateway', * title: 'Gateway Service', * location: client.registry.registryUri.replace('registry', 'gateway') * }); * } * }).then(doSomething); * * @returns {Promise} - First argument to the resolved Promise is the `Session` object that * has been updated */ generate(token) { const p = this.session.authenticateWithToken(token); return p.then(session =&gt; this.registry.fetch(session.currentOwner())).then(() =&gt; this.session); } /** * Log out an end user * * @returns {Session} */ logout() { return this.session.destroy(); } /** * Set the current tenancy for the user * * When switching tenancies, [this.registry]{@link Registry} will be * repopulated with the services available in that tenancy. * * Note: existing instances of {@link Service}s, {@link ResourcefulEndpoint}s etc * will not have the 'owner' updated when switching to a new tenancy. See the below * example for more info. * * @param {string} tenantName - the name of the tenancy to use * * @example &lt;caption&gt;Switching a tenancy&lt;/caption&gt; * await client.generate(some_token); * await client.setTenancy('test'); * * let identity = await client.service('identity'); * let usersEndpoint = identity.resourcefulEndpoint('users'); * await usersEndpoint.browse() // https://&lt;endpoint&gt;/data/users?owner=test * * await client.setTenancy('production'); * // At this point `identity` and `usersEndpoint` will still be doing * // `fetch`es with `?owner=test`. You will need to repopulate them * // as below * await usersEndpoint.browse() // https://&lt;endpoint&gt;/data/users?owner=test * * identity = await client.service('identity'); * usersEndpoint = identity.resourcefulEndpoint('users'); * await usersEndpoint.browse() // https://&lt;endpoint&gt;/data/users?owner=production * * @returns {Promise&lt;Session&gt;} */ setTenancy(tenantName) { // If the tenants.length === 0, it indicated that we are logging in // as an anonymous user, where the tenants would not have been set. if (this.session.tenants.length &gt; 0) { const tenantIds = this.session.tenants.map(item =&gt; item.name); if (!tenantIds.some(n =&gt; n === tenantName)) { return Promise.reject(new Error('Tenant does not exist')); } } this.session.currentTenant = tenantName; // Switching a tenancy whilst we've already logged in requires us // to update the registry return this.registry .fetch(tenantName) .then(() =&gt; this.session.populateAccess()) .then(() =&gt; this.session); } /** * Set the current directory * * This will only affect new authentications, * if the client is already authenticated, it will not do anything. * */ setDirectory(directory) { this.session.directory = directory; } /** * Set callback for when the Token is about to expire, * will be called before expiry based on the provided threshold * * Call with null to cancel the callback. * * @param {Function} callback Will be called with the current [session.access]{@link Session} * @param {Number} threshold Number of milliseconds _before_ expiry when callback will be invoked. Defaults to 60000 (1 minute) */ onExpiryWarning(callback, threshold = 60000) { this.session.setOnExpiryWarning(callback, threshold); } } // Export the query methods for use in non-es6 module environments. // e.g. // const Client = require('@pikselpalette/sequoia-js-client-sdk/dist/sequoia-client.js'); // const { where, field, param, textSearch } = Client; Client.where = where; Client.field = field; Client.param = param; Client.textSearch = textSearch; export default Client; × Search results Close "},"resource_collection.js.html":{"id":"resource_collection.js.html","title":"Source: resource_collection.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: resource_collection.js import Resource from './resource'; export const NO_RESOURCEFUL_ENDPOINT_ERROR = ` No resourceful endpoint tied to this resource collection. You should use resourcefulEndpoint.browse(), or supply a ResourcefulEndpoint instance when creating this collection. `; export const NO_NEXT_PAGE_ERROR = 'No next page'; export const NO_PREVIOUS_PAGE_ERROR = 'No previous page'; /** * A pagination aware collection of {@link Resource} objects. * * This class should not be used directly, but should instead be obtained * from {@link ResourcefulEndpoint} methods * * @param {Object} rawData - Raw JSON response from the Sequoia endpoint * @param {string} initialCriteria - the initial filter criteria used when requesting from this endpoint * @param {ResourcefulEndpoint} resourcefulEndpoint - The {@link ResourcefulEdnpoint} that created this ResourceCollection * * @property {Object} rawData - Raw JSON response from the Sequoia endpoint * @property {string} initialCriteria - the initial filter criteria used when requesting from this endpoint * @property {ResourcefulEndpoint} resourcefulEndpoint - The {@link ResourcefulEdnpoint} that created this ResourceCollection * @property {Resource[]} collection - Array of {@link Resource} objects * * @since 0.0.2 * * @private */ class ResourceCollection { /** * @param {Object} rawData - Raw JSON response from the Sequoia endpoint * @param {string} initialCriteria - the initial filter criteria used when requesting from this endpoint * @param {ResourcefulEndpoint} resourcefulEndpoint - The {@link ResourcefulEdnpoint} that created this ResourceCollection * * @returns {Resource} */ constructor(rawData, initialCriteria, resourcefulEndpoint) { /** @property {string} - the initial filter criteria used when requesting from this endpoint */ this.initialCriteria = initialCriteria; /** @property {ResourcefulEndpoint} - The {@link ResourcefulEdnpoint} that created this ResourceCollection */ this.resourcefulEndpoint = resourcefulEndpoint; /** @property {Resource[]} - Array of {@link Resource} objects */ this.collection = []; this.setData(rawData); } /** * Updates `rawData` with the json returned from the Sequoia service and sets * `collection` to an array of `{@link Resource}s * * Linked resources are collated into the individual {@link Resource}s created * for each item in the collection if they have relationship info. e.g. * Assets that are linked to Contents will have a `contentRef` - if this is present, * each Content instance will have a linked.assets[] with only the related Assets * * If there is no relationship specified in linked resources, (e.g. linked Customers * against Subscriptions from the Payment service) then each Subscription instance * will have *all* of the Customers avaliable as linked.customers[] * * @param {Object} rawData - json from a Sequoia `browse` request * * @private * * @returns {ResourceCollection} - self */ setData(rawData) { this.rawData = rawData; // Without a descriptor, we don't know truly know what to pick out if (this.resourcefulEndpoint &amp;&amp; this.rawData &amp;&amp; this.rawData[this.resourcefulEndpoint.pluralName]) { this.collection = this.rawData[this.resourcefulEndpoint.pluralName].map((content) =&gt; { const resource = Object.assign({}, content); // Copy if (this.rawData.linked) { const linkByRefName = `${this.resourcefulEndpoint.singularName}Ref`; resource.linked = {}; Object.keys(this.rawData.linked).forEach((link) =&gt; { resource.linked[link] = this.rawData.linked[link].filter((item) =&gt; { // If a `linkByRefName` exists on this link, filter only those // that are directly linked (this helps when `browsing()` a list of // disparate content where links come back for every item in the list // (e.g. metatdata/contents -&gt; linked assets). // However, some resourcefuls have links without this explicitly set // e.g. payment/subscriptions -&gt; linked customers if (item[linkByRefName]) { return item[linkByRefName] === resource.ref; } /* istanbul ignore next */ return true; }); }); } return new Resource(resource, this.resourcefulEndpoint); }); } return this; } /** * Current page in the pagination set * @type {number} */ get page() { return this.rawData.meta.page; } /** * Number of items per page in the pagination set * @type {number} */ get perPage() { return this.rawData.meta.perPage; } /** * Total number of Resources in the catalogue matching our criteria * @type {number} */ get totalCount() { if (this.rawData &amp;&amp; this.rawData.meta &amp;&amp; this.rawData.meta.totalCount) { return this.rawData.meta.totalCount; } return this.collection.length; } /** * Fetch the next page of results * * @see {@link ResourceCollection#fetch} * * @returns {Promise} */ nextPage() { if (this.rawData.meta.next) { return this.fetch(this.rawData.meta.next); } return Promise.reject(NO_NEXT_PAGE_ERROR); } /** * Fetch the previous page of results * * @see {@link ResourceCollection#fetch} * * @returns {Promise} */ previousPage() { if (this.rawData.meta.prev) { return this.fetch(this.rawData.meta.prev); } return Promise.reject(NO_PREVIOUS_PAGE_ERROR); } /** * Fetch the first page of results * * @see {@link ResourceCollection#fetch} * * @returns {Promise} */ firstPage() { return this.fetch(this.rawData.meta.first); } /** * Fetch the last page of results * * @see {@link ResourceCollection#fetch} * * @returns {Promise} */ lastPage() { return this.fetch(this.rawData.meta.last); } /** * Fetch a specific page of results * * @param {number} pageNumber - the number of the page to fetch * * @todo Boundary checking? * @todo This could likely be easier to use with the initialCriteria * * @see {@link ResourceCollection#fetch} * * @returns {Promise} */ getPage(pageNumber) { return this.fetch(this.rawData.meta.first.replace(/&amp;page=\\d+/, `&amp;page=${pageNumber}`)); } /** * Update the collection with new data from the server. This will * also return the new ResourceCollection as a convenience. * * @param {string?} newCriteria - query string criteria to send to {@link ResourcefulEndpoint#browse} * * @private * * @returns {Promise} - The new {@link ResourceCollection} just fetched */ fetch(newCriteria) { let criteria = this.initialCriteria || ''; if (newCriteria) { criteria = newCriteria; } // Remove everything before the query string (meta.first etc all have the full path // before the quesy string, which we don't want) and the owner param as the ResourcefulEndpoint // will add that criteria = criteria.replace(/^.+\\?/, '').replace(/&amp;?owner=[^&amp;]+/, ''); if (this.resourcefulEndpoint) { return this.resourcefulEndpoint.browse(criteria).then((newResource) =&gt; { this.rawData = newResource.rawData; this.collection = newResource.collection; return newResource; }); } return Promise.reject(NO_RESOURCEFUL_ENDPOINT_ERROR); } /** * Get a JSON representation of this collection's keys/values * * @returns {Object} */ toJSON() { return this.collection.map(resource =&gt; resource.toJSON()); } /** * Get a stringified version of this {@link ResourceCollection} that is suitable * for saving to sequoia. * * Simply wraps the JSON of the resource collection as an array in the &lt;pluralName&gt;[] property * * @returns {string} */ serialise() { return JSON.stringify({ [this.resourcefulEndpoint.pluralName]: this.toJSON() }, null, ' '); } /** * Get an array of ResourceCollections populated with a maximum of the `size` * paramater {@link Resource}s in each. * * Sequoia has limits to how many Resources can be saved at once. This method is used * internally by {@link ResourceCollection#save} and {@link ResourceCollection#destroy} * to send the right amount of data. * * @param {number} [size={@link ResourcefulEndpoint#batchSize}] - The number of {@link Resource}s to return in each ResourceCollection * * @see {@link ResourcefulEndpoint#all} * * @returns {ResourceCollection[]} */ explode(size) { const batchSize = size !== undefined ? size : this.resourcefulEndpoint.batchSize; const numberOfPages = Math.ceil(this.totalCount / batchSize); return Array.from(new Array(numberOfPages), (x, i) =&gt; this.resourcefulEndpoint.newResourceCollection({ [this.resourcefulEndpoint.pluralName]: this.collection.slice(i * batchSize, (i * batchSize) + batchSize).map(r =&gt; r.toJSON()) })); } /** * Save (create or update) (POST/PUT) all the {@link Resource}s in this * ResourceCollection. * If the ResourceCollection has more items than the batchSize specified in the * descriptor, multiple calls will be made to the backend * * @see {@link ResourceCollection#explode} * @see {@link ResourcefulEndpoint#store} * * @returns {Promise} */ save() { if (this.resourcefulEndpoint) { return Promise.all(this.explode().map(c =&gt; this.resourcefulEndpoint.store(c) .catch((e) =&gt; { // Add the current collection to the error to allow // end users to inspect where the error occurred e.collection = c; throw e; }))); } return Promise.reject(NO_RESOURCEFUL_ENDPOINT_ERROR); } /** * Validate all the {@link Resource}s in this collection. * * @example * resourceCollection.validate().catch((resource) =&gt; { * // Show resource.errors[] * }).then(resourceCollection =&gt; resourceCollection.save()) * .then(() =&gt; { * // do something on successfully saving * }); * * * @see {@link Resource#validateField} * * @returns {Promise} */ validate() { return Promise.all(this.collection.map(resource =&gt; resource.validate())).then(() =&gt; this); } /** * Destroy (DELETE) all the {@link Resource}s in this ResourceCollection. * If the ResourceCollection has more items than the batchSize specified in the * descriptor, multiple calls will be made to the backend * * @example &lt;caption&gt;Destroy all content that went out of availability this year&lt;/caption&gt; * contents.all(where(field(&quot;availabilityEndAt&quot;).lessThan(&quot;2017&quot;))).then(resources =&gt; resources.destroy()); * * @see {@link ResourceCollection#explode} * @see {@link ResourcefulEndpoint#destroy} * * @returns {Promise} */ destroy() { if (this.resourcefulEndpoint) { return Promise.all(this.explode().map(c =&gt; this.resourcefulEndpoint.destroy(c.collection.map(r =&gt; r.ref).join(',')))); } return Promise.reject(NO_RESOURCEFUL_ENDPOINT_ERROR); } // Pragma Local collection methods /** * Add a {@link Resource} to the [local collection]{@link ResourceCollection#collection} * Note: this method does not implement any uniqueness constraints on the `ref`s of * objects/Resources being added. If this is required, use {@link ResourceCollection#findOrCreate} * * @param {Object|Resource} data - Can be either an existing Resource or a JSON object * to create a new Resource from * * @see {@link ResourcefulEndpoint#newResource} * * @returns {!Resource} */ add(data) { let resource = data; if (!(data instanceof Resource)) { resource = this.resourcefulEndpoint.newResource(data); } this.collection.push(resource); return resource; } /** * Remove a {@link Resource} from the [local collection]{@link ResourceCollection#collection} * Will return the found {@link Resource} or null if it does not exist * * @param {string} ref - the ref of the resource to remove * * @returns {?Resource} */ remove(ref) { const index = this.collection.findIndex(r =&gt; r.ref === ref); if (index === -1) { return null; } const [resource] = this.collection.splice(index, 1); return resource; } /** * Returns a {@link Resource} if it exists in the [local collection]{@link ResourceCollection#collection} * with the supplied `ref` * * @param {string} ref - The ref of the resource to find * * @returns {?Resource} */ find(ref) { return this.collection.find(r =&gt; r.ref === ref); } /** * Find a resource in the [local collection]{@link ResourceCollection#collection} or create (and add * to the local collection) a Resource from the supplied object * * @param {Resource|Object} - the resource to find or create * * @returns {!Resource} */ findOrCreate(resource) { const existingResource = this.findWhere(resource instanceof Resource ? resource.toJSON() : resource); if (existingResource) { return existingResource; } return this.add(resource); } /** * Filter on `ref` when a string is supplied. * Filter by a custom function by supplying a `function` * Or filter by key/value pairs in an Object * @typedef {(string|function|Object)} Criteria */ /** * Find a Resource in the [local collection]{@link ResourceCollection#collection} or `null` if not found * The below examples assume the variable contents is populated with the * result of `client.service('metadata').then(s =&gt; s.resourcefulEndpoint('contents').all())` * * @param {Criteria} - The criteria to use for filtering the local collection * * @example &lt;caption&gt;Find all with a custom filter function&lt;/caption&gt; * // Find all of the Resources that have a title including 'die hard' that haven't had any tags applied yet * contents.where(r =&gt; r.title.toLowerCase().includes('die hard') &amp;&amp; !Array.isArray(r.tags)) * * @example &lt;caption&gt;Find all that match a given object&lt;/caption&gt; * // Find all of the Resources that are active and have a type of 'show' * contents.where({ type: 'show', active: true }) * * @see {@link ResourceCollection#where} * * @returns {Resource[]} */ where(criteria) { let callback; if (typeof criteria === 'function') { callback = criteria; } else if (typeof criteria === 'object' &amp;&amp; criteria !== null) { // Short circuit when we have a ref: if (criteria.hasOwnProperty('ref') &amp;&amp; criteria.ref !== undefined) { callback = r =&gt; r.ref === criteria.ref; } else { callback = r =&gt; Object.keys(criteria).reduce((acc, key) =&gt; { if (acc === true) { return r[key] === criteria[key]; } return false; }, true); } } else { return []; } return this.collection.filter(callback); } /** * Find a Resource in the [local collection]{@link ResourceCollection#collection} or `null` if not found * * @param {Criteria} - See {@link ResourceCollection#where} * * @see {@link ResourceCollection#where} * * @returns {?Resource} */ findWhere(criteria) { const resources = this.where(criteria); if (resources.length) { return resources[0]; } return null; } } export default ResourceCollection; × Search results Close "},"predications.js.html":{"id":"predications.js.html","title":"Source: predications.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: predications.js /** * A fluent interace for creating queries against resourceful endpoints * &lt;p&gt;It is not intended that this class will be used on its own by end users. * Instead, require it from {@link Query} as in the below example. * * @param {string} field - The field name to set criteria against * * @example * import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; * * where(field('title').notEqualTo('foo')).and(field(&quot;startedAt&quot;).lessThan(&quot;2014&quot;)) */ class Predications { constructor(field, raw = false) { if (raw) { this.field = field; } else { this.field = `with${field.charAt(0).toUpperCase()}${field.slice(1)}`; } } /** * Generates a url encoded criteria expression equivalent to: `field=value` * * @param {string} value - value for this predicate * * @example * field('engine').equalTo('diesel'); // returns 'engine=diesel' * * @returns {string} */ equalTo(value) { return `${this.field}=${value}`; } /** * Generates a url encoded criteria expression equivalent to: `field=!value` * * @param {string} value - value for this predicate * * @example * field('engine').notEqualTo('diesel'); // returns 'engine=!diesel' * * @returns {string} */ notEqualTo(value) { return `${this.field}=!${value}`; } /** * Generates a url encoded criteria expression equivalent to: `field=value1||value2` * * @param {...string} value - value(s) for this predicate * * @example * field('engine').oneOrMoreOf('diesel', 'petrol'); // returns 'engine=diesel||petrol' * * @returns {string} */ oneOrMoreOf(...value) { return `${this.field}=${value.join('||')}`; } /** * Generates a url encoded criteria expression equivalent to: `field=value*` * * @param {string} value - value for this predicate * * @example * field('engine').startsWith('diesel'); // returns 'engine=diesel*' * * @returns {string} */ startsWith(value) { return `${this.field}=${value}*`; } /** * Generates a url encoded criteria expression equivalent to: `field=*` * * @example * field('engine').exists(); // returns 'engine=*' * * @returns {string} */ exists() { return `${this.field}=*`; } /** * Generates a url encoded criteria expression equivalent to: `field=!*` * * @example * field('engine').notExists(); // returns 'engine=!*' * * @returns {string} */ notExists() { return `${this.field}=!*`; } /** * Generates a url encoded criteria expression equivalent to: `field=start/end` * * @param {(string|number)} start - start value for this predicate * @param {(string|number)} end - end value for this predicate * * @example * field('startedAt').between('2014', '2015'); // returns 'startedAt=2014/2015' * * @returns {string} */ between(start, end) { return `${this.field}=${start}/${end}`; } /** * Generates a url encoded criteria expression equivalent to: `field=!start/end` * * @param {(string|number)} start - start value for this predicate * @param {(string|number)} end - end value for this predicate * * @example * field('startedAt').notBetween('2014', '2015'); // returns 'startedAt=!2014/2015' * * @returns {string} */ notBetween(start, end) { return `${this.field}=!${start}/${end}`; } /** * Generates a url encoded criteria expression equivalent to: `field=!value/` * * @param {(string|number)} value - value for this predicate * * @example * field('startedAt').lessThan(2015); // returns 'engine=!2015/' * * @returns {string} */ lessThan(value) { return `${this.field}=!${value}/`; } /** * Generates a url encoded criteria expression equivalent to: `field=/value` * * @param {(string|number)} value - value for this predicate * * @example * field('startedAt').lessThanOrEqualTo(2015); // returns 'startedAt=/2015' * * @returns {string} */ lessThanOrEqualTo(value) { return `${this.field}=/${value}`; } /** * Generates a url encoded criteria expression equivalent to: `field=!/value` * * @param {(string|number)} value - value for this predicate * * @example * field('startedAt').greaterThan(2015); // returns 'startedAt=!/2015' * * @returns {string} */ greaterThan(value) { return `${this.field}=!/${value}`; } /** * Generates a url encoded criteria expression equivalent to: `field=value/` * * @param {(string|number)} value - value for this predicate * * @example * field('startedAt').greaterThanOrEqualTo(2015); // returns 'startedAt=2015/' * * @returns {string} */ greaterThanOrEqualTo(value) { return `${this.field}=${value}/`; } } export default Predications; × Search results Close "},"query.js.html":{"id":"query.js.html","title":"Source: query.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: query.js import Predications from './predications'; /** * A fluent interace for creating queries against resourceful endpoints * * @param {string?} query - (private) Initial query string to append to. * @param {string?} sort - (private) What to sort the query on * @param {string} [sortModifier=''] - (private) Sort modifier. Either empty string or '-' * * @requires {@link Predications} * * @example * import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; * * endpoint.browse(where(field('startedAt').greaterThanOrEqualTo(2015)) * .and(field('tags').equalTo('showcase')) * .fields('title', 'mediumSynopsis','duration', 'ref') * .include('assets').page(1).perPage(24).orderByUpdatedAt().desc().count()) * .then(json =&gt; { ... }); * */ class Query { constructor(query) { this.query = query || ''; this.sort = null; this.sortModifier = ''; } /** * Concatenate a new query with the previous one * * @param {string} query - A query string to append (without leading ampersand). * Usually returned from a call to `field` * * @example * where(field('startedAt').greaterThanOrEqualTo(2015)) * .and(field('tags').equalTo('showcase')) * * @since 0.0.2 * * @returns {Query} */ and(query) { this.query += `&amp;${query}`; return this; } /** * Will return `totalCount` on the payload * * @returns {Query} */ count() { this.query += '&amp;count=true'; return this; } /** * Appends `include=value1,value2` to the query * * @param {...string} includes - includes(s) (linked resources) to return in the json response * * @example * where().include('assets', 'categories') * // appends `include=assets,categories` to the query * * @returns {Query} */ include(...includes) { this.query += `&amp;include=${includes.join(',')}`; return this; } /** * Appends `lang=value` to the query * * @param {string} value - ISO 639-1 code for the language you want results returned in * * @example * where().lang('de') * // appends `lang=de` to the query * * @returns {Query} */ lang(value) { this.query += `&amp;lang=${value}`; return this; } /** * Appends `fields=value1,value2` to the query * * @param {...string} fieldName - field(s) to return in the json response * * @example * where().fields('title', 'mediumSynopsis','duration', 'ref') * // appends `fields=title,mediumSynopsis,duration,ref` to the query * * @returns {Query} */ fields(...fieldName) { this.query += `&amp;fields=${fieldName.join(',')}`; return this; } /** * Appends `page=value` to the query * * @param {(string|number)} value - page of results to request * * @example * where().page(9) * // appends `page=9` to the query * * @returns {Query} */ page(value) { this.query += `&amp;page=${value}`; return this; } /** * Appends `perPage=value` to the query * * @param {(string|number)} value - how many items to return per page of results * * @example * where().perPage(24) * // appends `perPage=24` to the query * * @returns {Query} */ perPage(value) { this.query += `&amp;perPage=${value}`; return this; } /** * Set order to ascending * * @returns {Query} */ asc() { this.sortModifier = ''; return this; } /** * Set order to descending * * @returns {Query} */ desc() { this.sortModifier = '-'; return this; } /** * Appends `sort=[-]fieldName` to the query, where `[-]` is toggled * depending on the call to {@link Query#asc} or {@link Query#desc} * * @see {@link Query#orderBy} * * @returns {Query} */ orderBy(fieldName) { this.sort = fieldName; return this; } /** * Convenience method for ordering by 'owner' * * @see {@link Query#orderBy} * * @returns {Query} */ orderByOwner() { return this.orderBy('owner'); } /** * Convenience method for ordering by 'name' * * @see {@link Query#orderBy} * * @returns {Query} */ orderByName() { return this.orderBy('name'); } /** * Convenience method for ordering by 'createdAt' * * @see {@link Query#orderBy} * * @returns {Query} */ orderByCreatedAt() { return this.orderBy('createdAt'); } /** * Convenience method for ordering by 'createdBy' * * @see {@link Query#orderBy} * * @returns {Query} */ orderByCreatedBy() { return this.orderBy('createdBy'); } /** * Convenience method for ordering by 'updatedAt' * * @see {@link Query#orderBy} * * @returns {Query} */ orderByUpdatedAt() { return this.orderBy('updatedAt'); } /** * Convenience method for ordering by 'updatedBy' * * @see {@link Query#orderBy} * * @returns {Query} */ orderByUpdatedBy() { return this.orderBy('updatedBy'); } /** * Turn the current Query into a string representation of a URI query * * @returns {string} */ toQueryString() { let { query } = this; if (this.sort) { query += `&amp;sort=${this.sortModifier}${this.sort}`; } return query; } } export default Query; export function where(criteria) { return new Query(criteria); } export function field(value) { return new Predications(value); } export function param(value) { return new Predications(value, true); } export function textSearch(value) { return `q=${value}`; } × Search results Close "},"registry.js.html":{"id":"registry.js.html","title":"Source: registry.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: registry.js import BusinessEndpoint from './business_endpoint.js'; import ResourcefulEndpoint from './resourceful_endpoint.js'; /** * Provides details of a Sequoia Service * * This class should not be used directly, but should instead be obtained * from {@link Client#service} * * @param {Transport} transport - Transport instance to use for fetching * @param {Object} data - JSON data returned from the service's raw description * e.g. https://metadata-sandbox.sequoia.piksel.com/descriptor/raw?owner=demo * * @property {Object} data - JSON data returned from the service's raw description * e.g. https://metadata-sandbox.sequoia.piksel.com/descriptor/raw?owner=demo * * @private */ class Service { constructor(transport, data) { this.transport = transport; this.data = data; } /** * Get a {@link ResourcefulEndpoint} from a Service * * @param {string} resourceName - e.g. 'contents' (the contents resourceful endpoint * from the meatatdata service) * * @returns {ResourcefulEndpoint} */ resourcefulEndpoint(resourceName) { if (!this.data || !(resourceName in this.data.resourcefuls)) { return null; } const resourceful = this.data.resourcefuls[resourceName]; resourceful.location = `${this.data.location}${resourceful.path}`; resourceful.tenant = this.data.tenant; return new ResourcefulEndpoint(this.transport, resourceful); } /** * Get an array of {@link ResourcefulEndpoint}s from a Service * * @param {...string} resourceName - e.g. 'assets', 'contents' (the assets and contents resourceful endpoint * from the meatatdata service) * * @example * const [ assets, contents ] = service.resourcefulEndpoints('assets', 'contents'); * * @returns {Array&lt;ResourcefulEndpoint&gt;} */ resourcefulEndpoints(...resourceName) { const endpoints = resourceName.length ? resourceName : Object.keys(this.data.resourcefuls); return endpoints.map(r =&gt; this.resourcefulEndpoint(r)); } /** * Get a {@link BusinessEndpoint} from a Service * * @param {string} name - e.g. 'feeds' (the feeds business endpoint * from the gateway service) * * @returns {BusinessEndpoint} */ businessEndpoint(endpointName, pathOptions) { const data = Object.assign({}, this.data); const { routes } = data; const endpoint = routes.find(route =&gt; route.name === endpointName); if (endpoint) { endpoint.location = this.data.location; endpoint.tenant = this.data.tenant; return new BusinessEndpoint(this.transport, endpoint, pathOptions); } return null; } /** * Get the list of resourcefuls for this Service * * @todo This method isn't used and also does not return an array - it is not advised to use yet * @todo Should this return an array of ResourcefulEndpoints instead? * * @returns {Object[]} - a list of resourcefuls populated from the descriptor */ resourcefuls() { return this.data.resourcefuls; } } /** * Access the Sequoia Registry based on the access of the current user * * @param {Transport} transport - Transport instance to use for fetching * @param {string} registryUri - URI of the Sequoia registry * e.g. https://registry-reference.sequoia.piksel.com * * @property {string} registryUri - URI of the Sequoia registry * e.g. https://registry-reference.sequoia.piksel.com * @property {Object[]} services - JSON data returned from the service's raw description * e.g. https://metadata-reference.sequoia.piksel.com/descriptor/raw?owner=demo * @property {string} tenant - The name of the current tenancy being used e.g. 'demo' * * See the {@link https://registry-reference.sequoia.piksel.com/docs|Registry docs} for more info * */ class Registry { constructor(transport, registryUri) { this.transport = transport; this.registryUri = registryUri; this.services = []; } /** * Fetch the registry for this user in this tenancy * * @param {string} tenant - The name of the tenancy to use e.g. 'demo' * * @returns {Promise} */ fetch(tenant) { this.tenant = tenant; return this.transport.get(`${this.registryUri}/services/${this.tenant}`).then((json) =&gt; { this.services = json.services; return json; }); } getServiceLocation(serviceName) { const service = this.services.find(item =&gt; item.name === serviceName); if (service) { return service.location; } return null; } /** * Get Service information from the registry. * * Rejects the Promise if a service is requested that doesn't exist for this user * (or at all) * * @param {string} serviceName - The name of the service to use e.g. 'metadata' * * @returns {Promise} */ getService(serviceName) { const service = this.services.find(item =&gt; item.name === serviceName); if (service) { return this.transport.get(`${service.location}/descriptor/raw?owner=${this.tenant}`).then((json) =&gt; { json.location = service.location; json.owner = service.owner; json.tenant = this.tenant; return new Service(this.transport, json); }); } return Promise.reject(new Error(`No service with name ${serviceName} exists`)); } /** * Get multiple Service information from the registry. * * Rejects the Promise if a service is requested that doesn't exist for this user * (or at all) * * @param {...string} serviceName - The name of the service to use e.g. 'metadata' * * @returns {Promise} */ getServices(...serviceName) { const services = serviceName.length ? serviceName : this.services.map(s =&gt; s.name); return Promise.all(services.map(s =&gt; this.getService(s))); } } export default Registry; export { Service }; × Search results Close "},"resource.js.html":{"id":"resource.js.html","title":"Source: resource.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: resource.js export const NO_RESOURCEFUL_ENDPOINT_ERROR = ` No resourceful endpoint tied to this resource. You should use resourcefulEndpoint.newResource(), or store this current resource with resourcefulEndpoint.store(resource). `; function isIterable(obj) { /* istanbul ignore next */ if (obj == null) { return false; } return typeof obj[Symbol.iterator] === 'function'; } /** * Validation error values * @readonly * @enum {number} */ const ValidationError = { /** No validation error */ NONE: 0, /** The field to validate does not exist in the descriptor */ NO_FIELD: 1, /** A required field was omitted */ REQUIRED_FIELD: 2, /** A value didn't match the restricted values for this field */ NOT_ALLOWED: 3, /** The value doesn't match the pattern allowed */ INVALID_VALUE: 4, /** The Map value doesn't match the pattern allowed for either its keys or values */ INVALID_MAP: 5 }; export { ValidationError }; /** * This class should not be used directly, but should instead be obtained * from {@link ResourcefulEndpoint} methods * * @example * const service = await client.service('metadata'); * const contents = service.resourcefulEndpoint('contents'); * * // Get an existing resource: * const content = await contents.readOne('some:ref'); * * // Create a new Resource in metadata/contents: * const newContent = contents.newResource({ * title: 'something', * synopsis: 'a really long synopsis' * }); * * // `service`, `content` and `newContent` are used throughtout the rest of the examples * * @private */ class Resource { /** * @param {Object} rawData - the raw json response from Sequoia * @param {ResourcefulEndpoint} resourcefulEndpoint - the {@link ResourcefulEndpoint} * that this Resource is a member of * * @returns {Resource} */ constructor(rawData, resourcefulEndpoint) { this.rawData = rawData; this.resourcefulEndpoint = resourcefulEndpoint; Object.assign(this, rawData); this.indirectlyLinkedResources = []; this.errors = []; } /** * Get a JSON representation of this Resources's keys/values * * If this Resource is tied to a {@link ResourcefulEndpoint} it will take the * keys and default values from the endpoint's descriptor. Otherwise it will * return which ever keys/values have been populated. * * @returns {Object} */ toJSON() { let json = null; if (this.getResourceFields()) { json = {}; Object.keys(this.getResourceFields()).forEach((key) =&gt; { json[key] = this.hasOwnProperty(key) ? this[key] : this.getResourceFields()[key].default; }); } else { json = this.rawData; } return json; } /** * Get a stringified version of this {@link Resource} that is suitable * for saving to sequoia. * * Simply wraps the JSON of the resource as an array in the &lt;pluralName&gt;[] property * * @example * * const resource = new Resource({ * ref: 'test:testcontent', * name: 'testcontent', * title: 'A test resource' * }, contents); * * resource.serialise(); * * // Returns: * '{&quot;contents&quot;:[{&quot;ref&quot;:&quot;test:testcontent&quot;,&quot;name&quot;:&quot;testcontent&quot;,&quot;title&quot;:&quot;A test resource&quot;}]}' * * @returns {string} */ serialise() { return JSON.stringify({ [this.resourcefulEndpoint.pluralName]: [this.toJSON()] }, null, ' '); } getResourceFields() { if (this.resourcefulEndpoint &amp;&amp; this.resourcefulEndpoint.resourceful) { return this.resourcefulEndpoint.resourceful.fields; } return null; } /** * Flush (save) Resources to the backend. Performs the actual write of * data to sequoia for [save()]{@link Resource#save} * * @see {@link Resource#save} * @private * * @returns {Promise} - the `fetch` Promise */ flush() { if (this.is_new === true) { return this.resourcefulEndpoint.store(this); } return this.resourcefulEndpoint.update(this); } /** * Save any [links]{@link Resource#link} that have been applied or resolve * immediately if there are none * * @private * * @returns {Promise} */ saveIndirectLinks() { if (this.indirectlyLinkedResources.length === 0) { return Promise.resolve(); } return Promise.all(this.indirectlyLinkedResources.map(link =&gt; link.save())); } /** * Save this Resource to the sequoia backend. * * Any [links]{@link Resource#link} that have also been applied in will also be saved at this point. * * @see {@link Resource#link} * @see {@link Resource#saveIndirectLinks} * @see {@link Resource#flush} * * @returns {Promise} */ save() { if (this.resourcefulEndpoint) { const clearLinks = (resource) =&gt; { this.indirectlyLinkedResources = []; return resource; }; // TODO: this should know whether this is a `new_resource` and `flush()` it first. // Should it also know the order? If only indirect links/relationships have been // added, don't bother `flush()ing` if the Resource exists already? return this.saveIndirectLinks().then(() =&gt; this.flush()).then(clearLinks); } return Promise.reject(NO_RESOURCEFUL_ENDPOINT_ERROR); } /** * Destroy (DELETE) this Resource. * * @see {@link ResourcefulEndpoint#destroy} * * @returns {Promise} */ destroy() { if (this.resourcefulEndpoint) { return this.resourcefulEndpoint.destroy(this); } return Promise.reject(NO_RESOURCEFUL_ENDPOINT_ERROR); } /** * @typedef {Object} Validation * @property {ValidationError} code - Error code * @property {string} message - What was invalid * @property {Object} typeInfo - The full typeInfo from the descriptor * @property {boolean} valid - Whether the field is valid or not */ /** * Validate a specific field in the Resource. * * @param {string} field - the field to validate e.g. 'ratings' * * @returns {Validation} */ validateField(field) { let code = ValidationError.NONE; let message = ''; let typeInformation; let valid = false; if (!(field in this.getResourceFields())) { message = `${field} does not exist`; code = ValidationError.NO_FIELD; } else { const currentField = this.getResourceFields()[field]; const { typeInfo, allowedValueMappings } = currentField; typeInformation = typeInfo; if (this[field] === undefined || this[field] === null) { if (currentField.required) { message = `${field} is required`; code = ValidationError.REQUIRED_FIELD; } } else if (currentField.readOnly === true) { // Skip readonly fields code = ValidationError.NONE; } else if (allowedValueMappings) { const allowedValues = Object.values(allowedValueMappings); if (!(allowedValues.includes(this[field]))) { message = `${field} is not one of ${allowedValues.join(', ')}`; code = ValidationError.NOT_ALLOWED; } } else if (typeInfo) { if ('pattern' in typeInfo) { // Simple value if (!((new RegExp(typeInfo.pattern)).test(this[field]))) { message = `${field} does not match ${typeInfo.pattern}`; code = ValidationError.INVALID_VALUE; } } else if ('keys' in typeInfo) { // Map const re = new RegExp(typeInfo.keys.pattern); Object.keys(this[field]).forEach((key) =&gt; { if (!(re.test(key))) { message += `${field}.${key} does not match ${typeInfo.keys.pattern}. `; code = ValidationError.INVALID_MAP; } else if ('values' in typeInfo) { const allowedValues = typeInfo.values[key].values; if (!(allowedValues.includes(this[field][key]))) { message += `${field}.${key} is not one of ${allowedValues.join(', ')}. `; code = ValidationError.INVALID_MAP; } } }); } } } if (code === 0) { valid = true; } return { code, field, message, typeInfo: typeInformation, valid }; } /** * Validate the resource. * * This method uses {@link Resource#validateField} on each field in the descriptor * and adds any invalid fields to the {@link Resource.errors} array for later querying. * * @example * contents.validate().catch((resource) =&gt; { * // Show resource.errors[] * }).then((resource) =&gt; { * if (!resource.errors.length) { * return resource.save().then(() =&gt; { * // do something on successfully saving * }); * } * * return Promise.reject(resource); * }).catch((resource) =&gt; { * // Or show resource.errors[] here (or errors from save()ing) * }); * * @see {@link Resource#validateField} * * @returns {Promise} */ validate() { this.errors = []; Object.keys(this.getResourceFields()).forEach((field) =&gt; { const validation = this.validateField(field); if (!validation.valid) { this.errors.push(validation); } }); if (this.errors.length) { return Promise.reject(new Error(this)); } return Promise.resolve(this); } /** * Get the relationship info from the descriptor. When passing in * a Resource, the relationship will be inferred from its * {@link ResourcefulEndpoint#pluralName}. Pass a string to be explicit. * Note, when using a String value, this uses the key name in the descriptor's * relationship info, not the resourceType. * * @param {string|Resource} resource - A `string` or {@link Resource} to get relationship information for * * @see {@link Resource#linkResource} * @see {@link ResourcefulEndpoint#relationshipFor} * * @private * * @returns {undefined} */ getRelationshipFor(resource) { if (typeof resource === 'string') { const { relationships } = this.resourcefulEndpoint; if (!(resource in relationships)) { throw new Error(`Relationship '${resource}' does not exist`); } return relationships[resource]; } return this.resourcefulEndpoint.relationshipFor(resource.resourcefulEndpoint.pluralName); } /** * Add a resource ref to the appropriate relationship so it is linked * to this Resource. * * @param {string} ref - the Resource's `ref` to link * @param {Object} relationship - The relationship from the descriptor obtained from {@link Resource#getRelationshipFor} * @param {Resource?} resource - Specify this when linking an indirect relationship. * Defaults to the current {@link Resource} instance * * @see {@link Resource#getRelationshipFor} * @private * */ linkRefToResource(ref, relationship, resource = this) { const { fieldNamePath } = relationship; // TODO: this will eventually be on the descriptor, but working // round it for now with the sequoia convention relationship.array = fieldNamePath.endsWith('Refs'); if (relationship.array === true) { const existingRelationships = resource[fieldNamePath]; if (!Array.isArray(existingRelationships)) { resource[fieldNamePath] = [ref]; } else if (!existingRelationships.includes(ref)) { resource[fieldNamePath].push(ref); } } else { resource[fieldNamePath] = ref; } } /** * Link a {@link Resource} with this Resource * * If the link is `direct`, simply update *this* Reource with the relationship info. * If the link is `indirect`, add a potential link (not yet saved) to the * `indirectlLinkedResources` array to be flush when calling [save()]{@link Resource#save} later. * * @param {Resource} resource - the Resource to link * @param {string} as - Override the relationship type for this link. * * @see {@link Resource#linkRefToResource} * * @private */ linkResource(resource, as) { const relationship = this.getRelationshipFor(as || resource); if (relationship.type === 'direct') { this.linkRefToResource(resource.ref, relationship); } else if (relationship.type === 'indirect') { this.linkRefToResource(this.ref, resource.getRelationshipFor(as || this), resource); this.indirectlyLinkedResources.push(resource); } } /** * Link one or many {@link Resource}s with this Resource * When linking an array of resources, if the relationship is not an array type * the last member of the array will become the only link. For example, * `content.link([...contents], 'parent')` will end up with * `resource.parentRef === contents[contents.length - 1].ref`. * Due to this, it is expected to only `link` certain resources at a time e.g. * `content.link(parentContent).link(assets).link(members, 'members').save()` * * @param {Resource[]} resource - the Resource (or array or Resources) to link * @param {string} as - Override the relationship type for this link. * * @example * const assets = service.resourcefulEndpoint('assets'); * const asset = await assets.readOne('some:asset-ref'); * * // If it's a known relationship, you don't have to bother providing the * // relationship type: * content.link(asset).save(); // Link and save * * // You can link a ResourceCollection (or any iterable): * const assets = await assets.browse(); // Get all assets already stored * content.link(assets).save(); // Link them all and save * * // You can provide the relationship type: * const relatedContent = await contents.readOne('some:other-ref'); * content.link(relatedContent).save(); // Will default to the 'parent' relationship * * content.link(relatedContent, 'members').save(); // Will now be a 'member' of the content (e.g. episodes of a series) * * @returns {Resource} - the current Resource instance */ link(resource, as) { if (!isIterable(resource)) { this.linkResource(resource, as); } else { resource.forEach(r =&gt; this.linkResource(r, as)); } return this; } /** * Query where the current resource has linked items of a particular * relationship kind. * * @param {string} relationship - The name of the relationship in the descriptor * e.g. 'assets', 'categories', 'parent' * * @example * content.hasLinked('assets'); * content.hasLinked('categories'); * * @returns {boolean} */ hasLinked(relationship) { return this.linked &amp;&amp; this.linked[relationship] &amp;&amp; this.linked[relationship].length &gt; 0; } // Convenience methods: // TODO: these should be rolled into an optional mixin /* istanbul ignore next */ getLinkedAssetOfType(mediaType) { if (this.hasLinked('assets')) { return this.linked.assets.filter(item =&gt; item.mediaType === mediaType); } return []; } /* istanbul ignore next */ get categories() { if (this.hasLinked('categories')) { return this.linked.categories; } return null; } /* istanbul ignore next */ get images() { return this.getLinkedAssetOfType('image'); } /* istanbul ignore next */ get videos() { return this.getLinkedAssetOfType('video'); } /* istanbul ignore next */ get trailers() { return this.videos.filter((item) =&gt; { const { tags } = item; if (tags) { return item.tags.includes('trailerondemand') || item.tags.includes('usage:trailer'); } return true; }); } /* istanbul ignore next */ get mainVideos() { return this.videos.filter((item) =&gt; { const { tags } = item; if (tags) { return !item.tags.includes('trailerondemand') &amp;&amp; !item.tags.includes('usage:trailer'); } return true; }); } /* istanbul ignore next */ primaryBoxArt() { return this.images.find((item) =&gt; { const { tags } = item; if (tags) { return item.tags.includes('portrait') || item.tags.includes('usage:boxart'); } return false; }); } /* istanbul ignore next */ primaryStill() { return this.images.find(item =&gt; item.tags &amp;&amp; (item.tags.includes('usage:still') || item.tags.includes('landscape'))); } /* istanbul ignore next */ trailer() { return this.trailers.find(item =&gt; item.tags &amp;&amp; item.tags.includes('console:primary')) || this.trailers[0]; } /* istanbul ignore next */ mainVideo(format) { return this.mainVideos.find(item =&gt; item.fileFormat === format); } } export default Resource; × Search results Close "},"resourceful_endpoint.js.html":{"id":"resourceful_endpoint.js.html","title":"Source: resourceful_endpoint.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: resourceful_endpoint.js import Query from './query'; import ResourceCollection, { NO_NEXT_PAGE_ERROR } from './resource_collection'; import Resource from './resource'; /** * ResourceFulEndpoint is the main interaction class against sequoia MDS endpoints. * This is what you'll be using to present data to users, for example content items, registered users etc. * * This class should not be used directly, but should instead be obtained * from {@link Service#resourcefulEndpoint} * * @param {Transport} transport - Transport instance to use for fetching * @param {Object} resourceful - JSON object describing this resourceful endpoint * (fetched from sequoia services 'descriptor') * * @example * // `contents` is used in the rest of the examples as our reference * // to a ResourcefulEndpoint * let contents; * * client.login('username', 'password').then(session =&gt; { * client.service('metadata').then(service =&gt; { * // Get a resourceful endpoint (this is synchronous as the service passed * // all the necessary data): * contents = service.resourcefulEndpoint('contents'); * // whatever * }); * }); * * @private */ class ResourcefulEndpoint { /** * @param {Object} resourceful - the Sequoia descriptor part that describes this endpoint * * @returns {ResourcefulEndpoint} */ constructor(transport, resourceful) { this.transport = transport; this.resourceful = resourceful; } get owner() { if (this.resourceful) { return this.resourceful.tenant; } return undefined; } /** * Turn the first item in the Sequoia response for this endpoint * into a {@link Resource}. This is a convenience for when operating * on individual Resources (read, update, store) where the sequoia response * is of the form * ``` * { * &lt;pluralName&gt;: [&lt;Resource&gt;], * meta: { ... } * } * ``` * * and we want to just operate on `Resource` * * @private * * @returns {Resource} */ responseToResource(json) { const resource = json[this.pluralName][0]; resource.linked = json.linked; return new Resource(resource, this); } /** * Obtain a new {@link Resource} for this endpoint. * A *new* resource is something that has not yet been created remotely. * * The `owner` property will be pre-populated with the current tenancy. Provding a * a value for this will override the current tenancy. This is useful when using * root tenancy but populating data on behalf of non-root tenancies. * See {@link Client#setTenancy} for more information. * * When a `name` property is provided, the `ref` (unique id) of this resource will * also be populated. This is useful for allowing linking different kinds of resources * together (see {@link Resource#link}) before saving the resources. * * There is a potential that `name`s you choose will conflict with already stored resources. * In this case, your changes will override the remote resource. See the below example * for how to handle these situations. * * @param {Object} data -data to populate the {@link Resource} with * @param {string=} data.owner -Defaults to the current tenancy name * * @example &lt;caption&gt;Create a new resource&lt;/caption&gt; * * const contentItem = contents.newResource({ * name: 'my-new-content', * title: 'something', * synopsis: 'a really long synopsis' * }); * * // You can now call methods on it, for example, a usual flow for creating * // a Resource would be: * * contentItem.validate() * .then(() =&gt; contentItem.save()) * .then(() =&gt; { * // Success, do something (redirect to a new view?) * }).catch((error) =&gt; { * // Validation error (from Resource object or the server), show the user what went wrong * }); * * @example &lt;caption&gt;Update or create a piece of content&lt;/caption&gt; * * const potentiallyNewContentItem = contents.newResource({ * name: 'my-potentially-new-content', * title: 'something new', * synopsis: 'a really long synopsis' * }); * * function findOrCreateResource(resourceful, data) { * return resourceful.readOne(`${resourceful.owner}:${data.name}`).catch(() =&gt; resourceful.newResource(data)); * } * * // You can now call methods on it, for example, a usual flow for creating * // a Resource would be: * * findOrCreateResource(contents, potentiallyNewContentItem) * .then((contentItem) =&gt; { * // Update with new data in case it was an existing resource * Object.assign(contentItem, potentiallyNewContentItem); * contentItem.duration = 'PT75M'; * * return contentItem.save()) * .then(() =&gt; { * // Success, do something (redirect to a new view?) * }).catch((error) =&gt; { * // Validation error (from the server), show the user what went wrong * }); * * @returns {Resource} */ newResource(data = { owner: this.owner }) { data.owner = data.owner || this.owner; if (data.ref === undefined &amp;&amp; data.owner &amp;&amp; data.name) { data.ref = `${data.owner}:${data.name}`; } return new Resource(Object.assign({ is_new: true }, data), this); } /** * Create a new {@link ResourceCollection} for this endpoint. * * Useful for creating many resources for ingest. * * @param {Array&lt;Object&gt;} data -data to populate the {@link ResourceCollection} with * * @example &lt;caption&gt;Create a new resource&lt;/caption&gt; * * const contentItems = contents.newResourceCollection([{ * name: 'one', * title: 'something', * synopsis: 'a really long synopsis' * }, * { * name: 'two', * title: 'something else', * synopsis: 'another really long synopsis' * }]); * * contentItems.validate() * .then(() =&gt; contentItems.save()) * .then(() =&gt; { * // Success, do something (redirect to a new view?) * }).catch((error) =&gt; { * // Validation error (from a nested Resource object or the server), show the user what went wrong * }); * * @returns {ResourceCollection} */ newResourceCollection(data) { return new ResourceCollection(data, '', this); } /** * Perform a browse (a GET for all items on this resourceful endpoint, with * optional `criteria`). The collection returned is the first page of results as * specified by `perPage` (or the Resourceful default e.g. 100) * * @param {(string|Query)} criteria - A query string to append to the request * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Trasport#get} * * @returns {Promise} - A {@link ResourceCollection} */ browse(criteria, options) { return this.transport.get(this.endPointUrl(null, criteria), options).then(json =&gt; new ResourceCollection(json, criteria, this)); } /** * The same as {@link ResourcefulEndpoint#browse} but will fetch *all* pages as a single * {@link ResourceCollection} * * @param {(string|Query)} criteria - A query string to append to the request * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Transport#get} * * @returns {Promise} - A {@link ResourceCollection} */ all(criteria, options) { let collection = null; const { pluralName } = this.resourceful; function accumulate(resourceCollection) { if (collection === null) { collection = Object.assign({}, resourceCollection); } else { // Things rely on rawData, not the derived collections collection.rawData[pluralName] = collection.rawData[pluralName].concat(resourceCollection.rawData[pluralName]); if (resourceCollection.rawData.linked) { Object.entries(resourceCollection.rawData.linked).forEach(([key, value]) =&gt; { if (!collection.rawData.linked[key]) collection.rawData.linked[key] = []; collection.rawData.linked[key] = collection.rawData.linked[key].concat(value); }); } } return resourceCollection .nextPage() .then(c =&gt; accumulate(c)) .catch((err) =&gt; { if (err === NO_NEXT_PAGE_ERROR) { return collection; } throw err; }) .then(() =&gt; collection); } return ( this.browse(criteria, options) .then(c =&gt; accumulate(c)) // Return a new ResourceCollection to ensure all is ok .then(c =&gt; new ResourceCollection(c.rawData, c.initialCriteria, c.resourcefulEndpoint)) ); } /** * Fetch (performs an HTTP GET on) an individual item, with optional criteria * * @param {string} ref - The unique `reference` for this item * @param {(string|Query)} criteria - A query string to append to the request * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Transport#get} * * @returns {Promise} - A {@link Resource} */ readOne(ref, criteria, options) { return this.transport.get(this.endPointUrl(ref, criteria), options).then(json =&gt; this.responseToResource(json)); } /** * Fetch (performs an HTTP GET on) many items, with optional criteria * * @param {Array&lt;String&gt;} refs - The unique `references` for the items * @param {(string|Query)} criteria - A query string to append to the request * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Transport#get} * * @returns {Promise} - A {@link ResourceCollection} */ readMany(refs, criteria, options) { return this.transport.get(this.endPointUrl(refs.join(','), criteria), options).then(json =&gt; new ResourceCollection(json, criteria, this)); } /** * Store (perform an HTTP POST for) a new item * * @param {Resource} resource - A {@link Resource} corresponding to the new resource you wish to save * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Transport#post} * * @todo Validate against the descriptor that this is a valid item to store * * @returns {Promise} */ store(resource, options) { return this.transport .post(this.endPointUrl(), Object.assign({ body: resource.serialise() }, options)) .then(json =&gt; this.responseToResource(json)); } /** * Update (perform an HTTP PUT for) an existing item * * @param {Object} resource - An Object corresponding to the new resouce you wish to save * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Transport#put} * * @todo Validate against the descriptor that this is a valid item to store * * @returns {Promise} */ update(resource, options) { return this.transport .put(this.endPointUrl(resource.ref), Object.assign({ body: resource.serialise() }, options)) .then(json =&gt; this.responseToResource(json)); } /** * Destroy (perform an HTTP DELETE for) an existing item * * @param {Object} resource - An Object corresponding to the resouce you wish to delete * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @see {@link Transport#destroy} * * @returns {Promise} */ destroy(resource, options) { let { ref } = resource; if (typeof resource === 'string') { ref = resource; } return this.transport.destroy(this.endPointUrl(ref), options); } /** * Get the relationship info for `relationshipName` from the descriptor * * @param {string} relationshipName - The name of the relationship e.g. 'assets' * * @throws {Error} - Throws when the relationship doesn't exist * * @example * * contents.relationshipFor('categories'); * * // Returns: * * { * &quot;description&quot;: &quot;The associated categories&quot;, * &quot;type&quot;: &quot;direct&quot;, * &quot;resourceType&quot;: &quot;categories&quot;, * &quot;fieldNamePath&quot;: &quot;categoryRefs&quot;, * &quot;fields&quot;: [ * &quot;ref&quot;, * &quot;title&quot;, * &quot;parentRef&quot;, * &quot;scheme&quot;, * &quot;value&quot; * ], * &quot;name&quot;: &quot;categories&quot;, * &quot;batchSize&quot;: 10 * } * * @returns {Object} */ relationshipFor(relationshipName) { const [name] = Object.entries(this.relationships).find(([, relationship]) =&gt; relationship.resourceType === relationshipName) || [undefined]; if (name) { return this.relationships[name]; } throw new Error(`Relationship '${relationshipName}' does not exist`); } /** * Get the relationship info from the descriptor. * * @example * * contents.relationships * * // Returns: * * { * &quot;children&quot;: { * &quot;description&quot;: &quot;The associated child contents&quot;, * &quot;type&quot;: &quot;indirect&quot;, * &quot;resourceType&quot;: &quot;contents&quot;, * &quot;filterName&quot;: &quot;withParentRef&quot;, * &quot;fields&quot;: [ * &quot;ref&quot;, * &quot;title&quot;, * &quot;parentRef&quot;, * &quot;type&quot; * ], * &quot;batchSize&quot;: 10, * &quot;name&quot;: &quot;children&quot; * }, * &quot;assets&quot;: { * &quot;description&quot;: &quot;The associated assets&quot;, * &quot;type&quot;: &quot;indirect&quot;, * &quot;resourceType&quot;: &quot;assets&quot;, * &quot;filterName&quot;: &quot;withContentRef&quot;, * &quot;fields&quot;: [ * &quot;ref&quot;, * &quot;name&quot;, * &quot;contentRef&quot;, * &quot;mediaType&quot;, * &quot;url&quot;, * &quot;fileFormat&quot;, * &quot;title&quot;, * &quot;fileSize&quot;, * &quot;tags&quot; * ], * &quot;batchSize&quot;: 10, * &quot;name&quot;: &quot;assets&quot; * } * } * * @type {object} */ get relationships() { return this.resourceful.relationships; } /** * Get the `pluralName` from the descriptor. The plural name is used to identify * the content array from the JSON response from Sequoia. e.g. for `assets`, the * response will be of the form: * * ```json * { * assets: [ asset resource, asset resource ... ], * linked: [ linked resource, linked resource ... ], * meta: { ...meta info } * } * ``` * @type {string} */ get pluralName() { return this.resourceful.pluralName; } /** * Get the `singularName` from the descriptor. The singular name is used to identify * what the specific resourceful resource is identified as. * * @type {string} */ get singularName() { return this.resourceful.singularName; } /** * Get the `hyphenatedPluralName` from the descriptor. The hyphenated plural name * is used to identify what the resourceful endpoint is called. e.g. a camelCased * resource (`pluralName`) like `contentSegments` will live under an HTTP endpoint * of `content-segments` * * @type {string} */ get hyphenatedPluralName() { return this.resourceful.hyphenatedPluralName; } /** * Get the `serviceName` from the descriptor. * * @type {string} */ get serviceName() { return this.resourceful.serviceName; } /** * Get the `batchSize` from the descriptor's `storeBatch` operation. * This is how many resources can be saved at once when saving a {@link ResourceCollection} * * @type {number} */ get batchSize() { const defaultBatchSize = 100; const { operations } = this.resourceful; if (operations &amp;&amp; operations.storeBatch) { return operations.storeBatch.limit || defaultBatchSize; } return defaultBatchSize; } // Private methods /** * Return a query string to append to the HTTP call. Will default to appending * `?owner=&lt;owner&gt;` * * @param {(string|Query)?} criteria - A (potential) query string to append to the request * * @private * * @returns {string} */ criteriaToQuery(criteria) { let query = `?owner=${this.owner}`; if (typeof criteria === 'string') { if (criteria !== '') { query += `&amp;${criteria}`; } } else if (criteria instanceof Query) { query += `&amp;${criteria.toQueryString()}`; } return query; } /** * Get the full URL to the resourceful endpoint/item we will send the request to * * @param {string?} ref - An optional unique ref for performing actions on a unique item (rather than browsing) * @param {(string|Query)?} criteria - A (potential) query string to append to the request * * @see {@link ResourcefulEndpoint#criteriaToQuery} * * @private * * @returns {string} */ endPointUrl(ref, criteria) { let resourceRef = ''; if (ref) { resourceRef = `/${ref}`; } return `${this.resourceful.location}/${this.resourceful.hyphenatedPluralName}${resourceRef}${this.criteriaToQuery(criteria)}`; } } export default ResourcefulEndpoint; × Search results Close "},"transport.js.html":{"id":"transport.js.html","title":"Source: transport.js","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Source: transport.js /** * Handles fetching. * * This class should not be used directly, but should instead be obtained * from {@link Service#resourcefulEndpoint} or {@link Service#businessEndpoint} * * @param {TransportDefaults?} options - The options to use with all fetch requests * * @property {TransportDefaults?} defaults - Stored from the initial 'options' parameter merged with the standard defaults * * @example * import Transport from '@pikselpalette/sequoia-js-client-sdk/lib/transport'; * * const transport = new Transport({method: 'POST'}); * transport.fetchWithDefaults('someurl').then((response) =&gt; console.log(response); * */ class Transport { /** * @typedef {Object} TransportDefaults * * Default fetch options to send with all `fetch` requests. * * @see {@link https://github.github.io/fetch/#options} */ constructor(options = {}) { this.defaults = Object.assign( {}, { method: 'GET', mode: 'cors', headers: { 'Content-Type': 'application/vnd.piksel+json', Accept: 'application/json' } }, options ); } /** * Performs a {@link https://github.github.io/fetch/|fetch} with the default options from {@link Transport} * * @param {string} url - sequoia url * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @returns {Promise} */ fetchWithDefaults(url, options = {}) { return fetch(url, Object.assign({}, this.defaults, options)).then((response) =&gt; { if (!response.ok) { const error = new Error(response.statusText); error.response = response; throw error; } if (response.status === 204) { return {}; } return response.json(); }); } /** * Performs an HTTP GET request * * @param {string} url - sequoia url * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @returns {Promise} */ get(url, options = {}) { return this.fetchWithDefaults(url, options); } /** * Performs an HTTP POST request * * @param {string} url - sequoia url * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @returns {Promise} */ post(url, options = {}) { return this.fetchWithDefaults(url, Object.assign({ method: 'POST' }, options)); } /** * Performs an HTTP PUT request * * @param {string} url - sequoia url * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @returns {Promise} */ put(url, options = {}) { return this.fetchWithDefaults(url, Object.assign({ method: 'PUT' }, options)); } /** * Performs an HTTP DELETE request * * @param {string} url - sequoia url * @param {object} options - [fetch options]{@link https://github.github.io/fetch/#options} * * @returns {Promise} */ destroy(url, options = {}) { return this.fetchWithDefaults(url, Object.assign({ method: 'DELETE' }, options)); } } export default Transport; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Global Members &lt;constant&gt; ValidationError :number Validation error values Type: number Properties: Name Type Default Description NONE number 0 No validation error NO_FIELD number 1 The field to validate does not exist in the descriptor REQUIRED_FIELD number 2 A required field was omitted NOT_ALLOWED number 3 A value didn't match the restricted values for this field INVALID_VALUE number 4 The value doesn't match the pattern allowed INVALID_MAP number 5 The Map value doesn't match the pattern allowed for either its keys or values Source: resource.js, line 20 Type Definitions AuthenticationOptions Type: Object Properties: Name Type Argument Description strategy string &lt;nullable&gt; 'pauth' or 'oauth' secret string &lt;nullable&gt; base64 clientId and clientSecret url string &lt;nullable&gt; Override the URL to hit for authentication. Useful for providing custom endpoints to provide an access_token Source: session.js, line 74 ClientOptions Options for the Client. Type: Object Properties: Name Type Argument Description directory string The directory to pass through to Session. registryUri string The registryUri to pass through to Registry. identityUri string &lt;nullable&gt; Optional identityUri to pass through to Session. Source: client.js, line 6 Criteria() Filter on ref when a string is supplied. Filter by a custom function by supplying a function Or filter by key/value pairs in an Object Source: resource_collection.js, line 422 TransportDefaults Default fetch options to send with all fetch requests. Type: Object Source: transport.js, line 19 See: https://github.github.io/fetch/#options Validation Type: Object Properties: Name Type Description code ValidationError Error code message string What was invalid typeInfo Object The full typeInfo from the descriptor valid boolean Whether the field is valid or not Source: resource.js, line 212 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Classes Classes BusinessEndpoint Client Predications Query Registry Resource ResourceCollection ResourcefulEndpoint Service Session Transport × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Tutorials Classes BusinessEndpoint Client Predications Query Registry Resource ResourceCollection ResourcefulEndpoint Service Session Transport × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError @pikselpalette/sequoia-js-client-sdk 1.1.0 Javascript Client SDK This SDK provides convenient access to the Piksel Palette RESTful services through a set of easy to use JS abstractions. You easily integrate Piksel Palette services into your website, webapp or node.js app and be running in no time. DocumentationIn depth instructions and the full API can be found in our developer documentation. More information about Piksel Palette services is available in the Piksel website. Installnpm i @pikselpalette/sequoia-js-client-sdk UsageES6 Web bundle (using webpack/browserify)// point to @pikselpalette/sequoia-js-client-sdk/dist/web/sequoia-client for a minified bundle import Client from '@pikselpalette/sequoia-js-client-sdk/lib/client'; import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; // Create a client: const client = new Client({ directory: 'piksel', registryUri: 'https://registry-sandbox.sequoia.piksel.com' }); client .login('username', 'password') .then(session =&gt; { // You can now query the session provided as the first argument (or // client.session); e.g. `session.isActive()` // Get a service:: client.service('metadata').then(service =&gt; { // Get a resourceful endpoint (this is synchronous as the service passed // all the necessary data): const contents = service.resourcefulEndpoint('contents'); contents .browse( where() .fields('title', 'mediumSynopsis', 'duration', 'ref') .include('assets') .page(1) .perPage(24) .orderByUpdatedAt() .desc() .count() ) .then(collection =&gt; { // Do something with the ResourceCollection returned }); }); }) .catch(error =&gt; { // Not logged in, inspect `error` to see why });Node/React Native// If you find a fetch alternative that works well with AWS, and is in active development, let us know. // Until then, we are using isomorphic-fetch. require('isomorphic-fetch'); const Client = require('@pikselpalette/sequoia-js-client-sdk/dist/node/sequoia-client'); const { where, field, param, textSearch } = Client; // Create a client: const client = new Client({ directory: 'piksel', registryUri: 'https://registry-sandbox.sequoia.piksel.com', token: bearerToken }); (async function init() { const service = await client.service('metadata'); const contents = service.resourcefulEndpoint('contents'); const collection = await contents.browse( where() .fields('title', 'mediumSynopsis', 'duration', 'ref') .include('assets') .page(1) .perPage(24) .orderByUpdatedAt() .desc() .count() ); // Do something with the ResourceCollection returned })();A note on fetch()The SDK uses the WHATWG fetch() standard which is available in most modern browsers, and in React Native. In order to use the SDK in older browsers, or in a Node environment where fetch() is not available, you need to supply your own fetch() polyfill. Some choices are: Isomorphic fetch - Web &amp; Node Cross Fetch - Web &amp; Node WHATWG Fetch - Web only DevelopmentBuilt using Node 9. Use avn to handle auto switching node versions. Building: npm run buildTesting: npm run test npm run test:watchMutation testing: npm run test:mutate npm run test:mutate -- --file=path/to/file/**/*.jsGenerate documentation (jsdoc): npm run docSamplesHere are some samples which make use of the SDK: AWS Lambda function running on the nodejs8.10 runtime. × Search results Close "},"BusinessEndpoint.html":{"id":"BusinessEndpoint.html","title":"Class: BusinessEndpoint","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: BusinessEndpoint BusinessEndpoint BusinessEndpoint is the main interaction class against non-resourceful sequoia endpoints. Business endpoints are simple rest-like endpoints. Due to the nature of them, this SDK is not (currently) intending to provide anything other than simple validation for paths and query strings. Objects are just the plain JSON returned from the service, unlike ResourcefulEndpoint which will send back ResourceCollection and Resources. This class should not be used directly, but should instead be obtained from Service#businessEndpoint &lt;private&gt; new BusinessEndpoint(transport, business) Parameters: Name Type Description transport Transport Transport instance to use for fetching business Object JSON object describing this business endpoint (fetched from sequoia services 'descriptor') Source: business_endpoint.js, line 41 Example // `contents` is used in the rest of the examples as our reference // to a ResourcefulEndpoint let feeds; client.generate().then(() =&gt; { client.service('feed').then((service) =&gt; { // Get a business endpoint (this is synchronous as the service passed // all the necessary data): feeds = service.businessEndpoint('feeds', { name: 'UTV-15246' }); // whatever }); }); Members requiredQueryParameterNames :Array.&lt;string&gt; Returns an array of query parameter names Type: Array.&lt;string&gt; Source: business_endpoint.js, line 135 Example // Returns e.g. ['currency', 'price'] requiredQueryParameters :Array.&lt;object&gt; Required query parameters for the business endpoint from the routes['name'].inputs.query portion of the descriptor Returns the raw objects Type: Array.&lt;object&gt; Source: business_endpoint.js, line 116 Example // Returns e.g. [{ &quot;type&quot;: &quot;name&quot;, &quot;meta&quot;: [{ &quot;sequoiaType&quot;: &quot;name&quot; }], &quot;invalids&quot;: [&quot;&quot; ], &quot;name&quot;: &quot;count&quot;, &quot;required&quot;: false }, { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;language to localise response to&quot;, &quot;invalids&quot;: [&quot;&quot;], &quot;name&quot;: &quot;lang&quot;, &quot;required&quot;: false }] Methods &lt;private&gt; criteriaToQuery(criteria) Return a query string to append to the HTTP call. Will default to appending ?owner=&lt;owner&gt; Parameters: Name Type Argument Description criteria string | Query &lt;nullable&gt; A (potential) query string to append to the request Source: business_endpoint.js, line 153 Throws: InvalidCriteriaException Returns: Type string &lt;private&gt; endPointUrl(criteria) Get the full URL to the business endpoint/item we will send the request to Parameters: Name Type Argument Description criteria string | Query &lt;nullable&gt; A (potential) query string to append to the request Source: business_endpoint.js, line 188 See: BusinessEndpoint#criteriaToQuery Throws: InvalidCriteriaException Returns: Type string fetch(criteria, options) Perform an action against the business endpoint. Note, the HTTP method comes from the routes['name'].method portion of the descriptor Parameters: Name Type Description criteria string | Query A query string to append to the request options object fetch options Source: business_endpoint.js, line 82 See: Transport#fetchWithDefaults Throws: InvalidCriteriaException Returns: JSON returned from the endpoint Type Promise × Search results Close "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Client Client Provides initial setup and subsequent access to the SDK new Client(options) Parameters: Name Type Description options ClientOptions Options for the Client. Properties: Name Type Description transport Transport a stored transport instance used for fetching session Session a stored session to query the current users' authentication state with registry Registry a stored registry reference to query Source: client.js, line 73 Tutorials: Getting Started Requires: Transport Session Registry Examples import Client from '@pikselpalette/sequoia-js-client-sdk/lib/client'; import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; // Create a client: const client = new Client({ directory: 'piksel', registry: 'https://registry-sandbox.sequoia.piksel.com' }); client.login('username', 'password').then(session =&gt; { // You can now query the session provided as the first argument (or // client.session); e.g. `session.isActive()` // Get a service:: client.service('metadata').then(service =&gt; { // Get a resourceful endpoint (this is synchronous as the service passed // all the necessary data): const contents = service.resourcefulEndpoint('contents'); contents.browse(where().fields('title', 'mediumSynopsis','duration', 'ref') .include('assets').page(1).perPage(24).orderByUpdatedAt().desc().count()) .then(json =&gt; { // Do something with the json returned }); }); }).catch(error =&gt; { // Not logged in, inspect `error` to see why }); // Adding a tenant argument to the Client means you can skip setting the tenant later on. const client = new Client({ directory: 'piksel', registry: 'https://registry-sandbox.sequoia.piksel.com', tenant: 'demo' }); // Adding a token argument to the Client means you do not need to call generate() // in a separate step. const client = new Client({ directory: 'piksel', registry: 'https://registry-sandbox.sequoia.piksel.com', token: 'yourGeneratedToken' }); Requires Transport Session Registry Methods generate(token) Generate a Session from an existing bearer token. It is also useful to use this if you acquire an access token via other means, i.e. an existing oauth mechanism for Sequoia Call this method without a token parameter to instantiate the client for anonymous usage. Note: currently the Sequoia registry does not provide anonymous access. See the below example for how to handle this currently. Parameters: Name Type Argument Description token string &lt;nullable&gt; an existing bearer token for an end user Source: client.js, line 196 Returns: First argument to the resolved Promise is the Session object that has been updated Type Promise Examples client.generate('some token').then(doSomething); // Anonymous usage: client.generate().catch((err) =&gt; { if (err.response &amp;&amp; err.response.status === 401) { client.registry.tenant = SQ_DIRECTORY; client.registry.services.push({ owner: 'root', name: 'identity', title: 'Identity Service', location: SQ_IDENTITY_URL }); client.registry.services.push({ owner: 'root', name: 'gateway', title: 'Gateway Service', location: client.registry.registryUri.replace('registry', 'gateway') }); } }).then(doSomething); login(username, password, options) Log an end user in with username and password credentials Parameters: Name Type Argument Description username string &lt;nullable&gt; the end user's username password string &lt;nullable&gt; the end user's password options AuthenticationOptions &lt;nullable&gt; Source: client.js, line 149 See: {Session#authenticateWithCredentials} Returns: First argument to the resolved Promise is the Session object that has been updatedc Type Promise Examples // Standard 'pauth' login client.login('test_username', 'test_password').then((session) =&gt; { // Do something with the session }); // 'pauth' style login to a custom endpoint client.login('test_username', 'test_password', { url: 'https://example.com/custom/pauth' }).then((session) =&gt; { // Custom url should return a json response of { 'access_token': &lt;token&gt; } // Do something with the session }); // Standard 'oauth' login (password grant) const secret = 'somebase64secret=='; client.login('test_username', 'test_password', { strategy: 'oauth', secret }).then((session) =&gt; { // Do something with the session }); // Client oauth (client credentials grant) const secret = 'somebase64secret=='; client.login(null, null, { strategy: 'oauth', secret }).then((session) =&gt; { // Do something with the session }); // login will reject when not passing a secret client.login('test_username', 'test_password', { strategy: 'oauth' }).catch((err) =&gt; { // Inspect `err` }); logout() Log out an end user Source: client.js, line 207 Returns: Type Session onExpiryWarning(callback, threshold) Set callback for when the Token is about to expire, will be called before expiry based on the provided threshold Call with null to cancel the callback. Parameters: Name Type Default Description callback function Will be called with the current session.access threshold Number 60000 Number of milliseconds before expiry when callback will be invoked. Defaults to 60000 (1 minute) Source: client.js, line 284 service() Get a Service from the Registry Source: client.js, line 92 See: Registry#getService Returns: Type Promise setDirectory() Set the current directory This will only affect new authentications, if the client is already authenticated, it will not do anything. Source: client.js, line 271 setTenancy(tenantName) Set the current tenancy for the user When switching tenancies, this.registry will be repopulated with the services available in that tenancy. Note: existing instances of Services, ResourcefulEndpoints etc will not have the 'owner' updated when switching to a new tenancy. See the below example for more info. Parameters: Name Type Description tenantName string the name of the tenancy to use Source: client.js, line 243 Returns: Type Promise.&lt;Session&gt; Example Switching a tenancy await client.generate(some_token); await client.setTenancy('test'); let identity = await client.service('identity'); let usersEndpoint = identity.resourcefulEndpoint('users'); await usersEndpoint.browse() // https://&lt;endpoint&gt;/data/users?owner=test await client.setTenancy('production'); // At this point `identity` and `usersEndpoint` will still be doing // `fetch`es with `?owner=test`. You will need to repopulate them // as below await usersEndpoint.browse() // https://&lt;endpoint&gt;/data/users?owner=test identity = await client.service('identity'); usersEndpoint = identity.resourcefulEndpoint('users'); await usersEndpoint.browse() // https://&lt;endpoint&gt;/data/users?owner=production × Search results Close "},"Predications.html":{"id":"Predications.html","title":"Class: Predications","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Predications Predications A fluent interace for creating queries against resourceful endpoints It is not intended that this class will be used on its own by end users. Instead, require it from Query as in the below example. new Predications(field) Parameters: Name Type Description field string The field name to set criteria against Source: predications.js, line 13 Example import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; where(field('title').notEqualTo('foo')).and(field(&quot;startedAt&quot;).lessThan(&quot;2014&quot;)) Methods between(start, end) Generates a url encoded criteria expression equivalent to: field=start/end Parameters: Name Type Description start string | number start value for this predicate end string | number end value for this predicate Source: predications.js, line 113 Returns: Type string Example field('startedAt').between('2014', '2015'); // returns 'startedAt=2014/2015' equalTo(value) Generates a url encoded criteria expression equivalent to: field=value Parameters: Name Type Description value string value for this predicate Source: predications.js, line 32 Returns: Type string Example field('engine').equalTo('diesel'); // returns 'engine=diesel' exists() Generates a url encoded criteria expression equivalent to: field=* Source: predications.js, line 86 Returns: Type string Example field('engine').exists(); // returns 'engine=*' greaterThan(value) Generates a url encoded criteria expression equivalent to: field=!/value Parameters: Name Type Description value string | number value for this predicate Source: predications.js, line 170 Returns: Type string Example field('startedAt').greaterThan(2015); // returns 'startedAt=!/2015' greaterThanOrEqualTo(value) Generates a url encoded criteria expression equivalent to: field=value/ Parameters: Name Type Description value string | number value for this predicate Source: predications.js, line 184 Returns: Type string Example field('startedAt').greaterThanOrEqualTo(2015); // returns 'startedAt=2015/' lessThan(value) Generates a url encoded criteria expression equivalent to: field=!value/ Parameters: Name Type Description value string | number value for this predicate Source: predications.js, line 142 Returns: Type string Example field('startedAt').lessThan(2015); // returns 'engine=!2015/' lessThanOrEqualTo(value) Generates a url encoded criteria expression equivalent to: field=/value Parameters: Name Type Description value string | number value for this predicate Source: predications.js, line 156 Returns: Type string Example field('startedAt').lessThanOrEqualTo(2015); // returns 'startedAt=/2015' notBetween(start, end) Generates a url encoded criteria expression equivalent to: field=!start/end Parameters: Name Type Description start string | number start value for this predicate end string | number end value for this predicate Source: predications.js, line 128 Returns: Type string Example field('startedAt').notBetween('2014', '2015'); // returns 'startedAt=!2014/2015' notEqualTo(value) Generates a url encoded criteria expression equivalent to: field=!value Parameters: Name Type Description value string value for this predicate Source: predications.js, line 46 Returns: Type string Example field('engine').notEqualTo('diesel'); // returns 'engine=!diesel' notExists() Generates a url encoded criteria expression equivalent to: field=!* Source: predications.js, line 98 Returns: Type string Example field('engine').notExists(); // returns 'engine=!*' oneOrMoreOf(value) Generates a url encoded criteria expression equivalent to: field=value1||value2 Parameters: Name Type Argument Description value string &lt;repeatable&gt; value(s) for this predicate Source: predications.js, line 60 Returns: Type string Example field('engine').oneOrMoreOf('diesel', 'petrol'); // returns 'engine=diesel||petrol' startsWith(value) Generates a url encoded criteria expression equivalent to: field=value* Parameters: Name Type Description value string value for this predicate Source: predications.js, line 74 Returns: Type string Example field('engine').startsWith('diesel'); // returns 'engine=diesel*' × Search results Close "},"Query.html":{"id":"Query.html","title":"Class: Query","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Query Query A fluent interace for creating queries against resourceful endpoints new Query(query, sort [, sortModifier]) Parameters: Name Type Argument Default Description query string &lt;nullable&gt; (private) Initial query string to append to. sort string &lt;nullable&gt; (private) What to sort the query on sortModifier string &lt;optional&gt; '' (private) Sort modifier. Either empty string or '-' Source: query.js, line 22 Requires: Predications Example import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; endpoint.browse(where(field('startedAt').greaterThanOrEqualTo(2015)) .and(field('tags').equalTo('showcase')) .fields('title', 'mediumSynopsis','duration', 'ref') .include('assets').page(1).perPage(24).orderByUpdatedAt().desc().count()) .then(json =&gt; { ... }); Requires Predications Methods and(query) Concatenate a new query with the previous one Parameters: Name Type Description query string A query string to append (without leading ampersand). Usually returned from a call to field Since: 0.0.2 Source: query.js, line 43 Returns: Type Query Example where(field('startedAt').greaterThanOrEqualTo(2015)) .and(field('tags').equalTo('showcase')) asc() Set order to ascending Source: query.js, line 143 Returns: Type Query count() Will return totalCount on the payload Source: query.js, line 53 Returns: Type Query desc() Set order to descending Source: query.js, line 153 Returns: Type Query fields(fieldName) Appends fields=value1,value2 to the query Parameters: Name Type Argument Description fieldName string &lt;repeatable&gt; field(s) to return in the json response Source: query.js, line 101 Returns: Type Query Example where().fields('title', 'mediumSynopsis','duration', 'ref') // appends `fields=title,mediumSynopsis,duration,ref` to the query include(includes) Appends include=value1,value2 to the query Parameters: Name Type Argument Description includes string &lt;repeatable&gt; includes(s) (linked resources) to return in the json response Source: query.js, line 69 Returns: Type Query Example where().include('assets', 'categories') // appends `include=assets,categories` to the query lang(value) Appends lang=value to the query Parameters: Name Type Description value string ISO 639-1 code for the language you want results returned in Source: query.js, line 85 Returns: Type Query Example where().lang('de') // appends `lang=de` to the query orderBy() Appends sort=[-]fieldName to the query, where [-] is toggled depending on the call to Query#asc or Query#desc Source: query.js, line 166 See: Query#orderBy Returns: Type Query orderByCreatedAt() Convenience method for ordering by 'createdAt' Source: query.js, line 200 See: Query#orderBy Returns: Type Query orderByCreatedBy() Convenience method for ordering by 'createdBy' Source: query.js, line 211 See: Query#orderBy Returns: Type Query orderByName() Convenience method for ordering by 'name' Source: query.js, line 189 See: Query#orderBy Returns: Type Query orderByOwner() Convenience method for ordering by 'owner' Source: query.js, line 178 See: Query#orderBy Returns: Type Query orderByUpdatedAt() Convenience method for ordering by 'updatedAt' Source: query.js, line 222 See: Query#orderBy Returns: Type Query orderByUpdatedBy() Convenience method for ordering by 'updatedBy' Source: query.js, line 233 See: Query#orderBy Returns: Type Query page(value) Appends page=value to the query Parameters: Name Type Description value string | number page of results to request Source: query.js, line 117 Returns: Type Query Example where().page(9) // appends `page=9` to the query perPage(value) Appends perPage=value to the query Parameters: Name Type Description value string | number how many items to return per page of results Source: query.js, line 133 Returns: Type Query Example where().perPage(24) // appends `perPage=24` to the query toQueryString() Turn the current Query into a string representation of a URI query Source: query.js, line 242 Returns: Type string × Search results Close "},"Registry.html":{"id":"Registry.html","title":"Class: Registry","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Registry Registry Access the Sequoia Registry based on the access of the current user new Registry(transport, registryUri) Parameters: Name Type Description transport Transport Transport instance to use for fetching registryUri string URI of the Sequoia registry e.g. https://registry-reference.sequoia.piksel.com Properties: Name Type Description registryUri string URI of the Sequoia registry e.g. https://registry-reference.sequoia.piksel.com services Array.&lt;Object&gt; JSON data returned from the service's raw description e.g. https://metadata-reference.sequoia.piksel.com/descriptor/raw?owner=demo tenant string The name of the current tenancy being used e.g. 'demo' See the Registry docs for more info Source: registry.js, line 114 Methods fetch(tenant) Fetch the registry for this user in this tenancy Parameters: Name Type Description tenant string The name of the tenancy to use e.g. 'demo' Source: registry.js, line 128 Returns: Type Promise getService(serviceName) Get Service information from the registry. Rejects the Promise if a service is requested that doesn't exist for this user (or at all) Parameters: Name Type Description serviceName string The name of the service to use e.g. 'metadata' Source: registry.js, line 158 Returns: Type Promise getServices(serviceName) Get multiple Service information from the registry. Rejects the Promise if a service is requested that doesn't exist for this user (or at all) Parameters: Name Type Argument Description serviceName string &lt;repeatable&gt; The name of the service to use e.g. 'metadata' Source: registry.js, line 184 Returns: Type Promise × Search results Close "},"Resource.html":{"id":"Resource.html","title":"Class: Resource","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Resource Resource This class should not be used directly, but should instead be obtained from ResourcefulEndpoint methods &lt;private&gt; new Resource(rawData, resourcefulEndpoint) Parameters: Name Type Description rawData Object the raw json response from Sequoia resourcefulEndpoint ResourcefulEndpoint the ResourcefulEndpoint that this Resource is a member of Source: resource.js, line 58 Example const service = await client.service('metadata'); const contents = service.resourcefulEndpoint('contents'); // Get an existing resource: const content = await contents.readOne('some:ref'); // Create a new Resource in metadata/contents: const newContent = contents.newResource({ title: 'something', synopsis: 'a really long synopsis' }); // `service`, `content` and `newContent` are used throughtout the rest of the examples Methods destroy() Destroy (DELETE) this Resource. Source: resource.js, line 204 See: ResourcefulEndpoint#destroy Returns: Type Promise &lt;private&gt; flush() Flush (save) Resources to the backend. Performs the actual write of data to sequoia for save() Source: resource.js, line 145 See: Resource#save Returns: the fetch Promise Type Promise &lt;private&gt; getRelationshipFor(resource) Get the relationship info from the descriptor. When passing in a Resource, the relationship will be inferred from its ResourcefulEndpoint#pluralName. Pass a string to be explicit. Note, when using a String value, this uses the key name in the descriptor's relationship info, not the resourceType. Parameters: Name Type Description resource string | Resource A string or Resource to get relationship information for Source: resource.js, line 351 See: Resource#linkResource ResourcefulEndpoint#relationshipFor Returns: Type undefined hasLinked(relationship) Query where the current resource has linked items of a particular relationship kind. Parameters: Name Type Description relationship string The name of the relationship in the descriptor e.g. 'assets', 'categories', 'parent' Source: resource.js, line 478 Returns: Type boolean Example content.hasLinked('assets'); content.hasLinked('categories'); link(resource, as) Link one or many Resources with this Resource When linking an array of resources, if the relationship is not an array type the last member of the array will become the only link. For example, content.link([...contents], 'parent') will end up with resource.parentRef === contents[contents.length - 1].ref. Due to this, it is expected to only link certain resources at a time e.g. content.link(parentContent).link(assets).link(members, 'members').save() Parameters: Name Type Description resource Array.&lt;Resource&gt; the Resource (or array or Resources) to link as string Override the relationship type for this link. Source: resource.js, line 455 Returns: the current Resource instance Type Resource Example const assets = service.resourcefulEndpoint('assets'); const asset = await assets.readOne('some:asset-ref'); // If it's a known relationship, you don't have to bother providing the // relationship type: content.link(asset).save(); // Link and save // You can link a ResourceCollection (or any iterable): const assets = await assets.browse(); // Get all assets already stored content.link(assets).save(); // Link them all and save // You can provide the relationship type: const relatedContent = await contents.readOne('some:other-ref'); content.link(relatedContent).save(); // Will default to the 'parent' relationship content.link(relatedContent, 'members').save(); // Will now be a 'member' of the content (e.g. episodes of a series) &lt;private&gt; linkRefToResource(ref, relationship, resource) Add a resource ref to the appropriate relationship so it is linked to this Resource. Parameters: Name Type Argument Description ref string the Resource's ref to link relationship Object The relationship from the descriptor obtained from Resource#getRelationshipFor resource Resource &lt;nullable&gt; Specify this when linking an indirect relationship. Defaults to the current Resource instance Source: resource.js, line 378 See: Resource#getRelationshipFor &lt;private&gt; linkResource(resource, as) Link a Resource with this Resource If the link is direct, simply update this Reource with the relationship info. If the link is indirect, add a potential link (not yet saved) to the indirectlLinkedResources array to be flush when calling save() later. Parameters: Name Type Description resource Resource the Resource to link as string Override the relationship type for this link. Source: resource.js, line 412 See: Resource#linkRefToResource save() Save this Resource to the sequoia backend. Any links that have also been applied in will also be saved at this point. Source: resource.js, line 180 See: Resource#link Resource#saveIndirectLinks Resource#flush Returns: Type Promise &lt;private&gt; saveIndirectLinks() Save any links that have been applied or resolve immediately if there are none Source: resource.js, line 161 Returns: Type Promise serialise() Get a stringified version of this Resource that is suitable for saving to sequoia. Simply wraps the JSON of the resource as an array in the [] property Source: resource.js, line 122 Returns: Type string Example const resource = new Resource({ ref: 'test:testcontent', name: 'testcontent', title: 'A test resource' }, contents); resource.serialise(); // Returns: '{&quot;contents&quot;:[{&quot;ref&quot;:&quot;test:testcontent&quot;,&quot;name&quot;:&quot;testcontent&quot;,&quot;title&quot;:&quot;A test resource&quot;}]}' toJSON() Get a JSON representation of this Resources's keys/values If this Resource is tied to a ResourcefulEndpoint it will take the keys and default values from the endpoint's descriptor. Otherwise it will return which ever keys/values have been populated. Source: resource.js, line 85 Returns: Type Object validate() Validate the resource. This method uses Resource#validateField on each field in the descriptor and adds any invalid fields to the Resource.errors array for later querying. Source: resource.js, line 317 See: Resource#validateField Returns: Type Promise Example contents.validate().catch((resource) =&gt; { // Show resource.errors[] }).then((resource) =&gt; { if (!resource.errors.length) { return resource.save().then(() =&gt; { // do something on successfully saving }); } return Promise.reject(resource); }).catch((resource) =&gt; { // Or show resource.errors[] here (or errors from save()ing) }); validateField(field) Validate a specific field in the Resource. Parameters: Name Type Description field string the field to validate e.g. 'ratings' Source: resource.js, line 227 Returns: Type Validation × Search results Close "},"ResourceCollection.html":{"id":"ResourceCollection.html","title":"Class: ResourceCollection","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: ResourceCollection ResourceCollection A pagination aware collection of Resource objects. This class should not be used directly, but should instead be obtained from ResourcefulEndpoint methods &lt;private&gt; new ResourceCollection(rawData, initialCriteria, resourcefulEndpoint) Parameters: Name Type Description rawData Object Raw JSON response from the Sequoia endpoint initialCriteria string the initial filter criteria used when requesting from this endpoint resourcefulEndpoint ResourcefulEndpoint The ResourcefulEdnpoint that created this ResourceCollection Properties: Name Type Description rawData Object Raw JSON response from the Sequoia endpoint initialCriteria string the initial filter criteria used when requesting from this endpoint resourcefulEndpoint ResourcefulEndpoint The ResourcefulEdnpoint that created this ResourceCollection collection Array.&lt;Resource&gt; Array of Resource objects Since: 0.0.2 Source: resource_collection.js, line 31 Members collection Properties: Type Description Array.&lt;Resource&gt; Array of Resource objects Source: resource_collection.js, line 45 initialCriteria Properties: Type Description string the initial filter criteria used when requesting from this endpoint Source: resource_collection.js, line 41 page :number Current page in the pagination set Type: number Source: resource_collection.js, line 110 perPage :number Number of items per page in the pagination set Type: number Source: resource_collection.js, line 118 resourcefulEndpoint Properties: Type Description ResourcefulEndpoint The ResourcefulEdnpoint that created this ResourceCollection Source: resource_collection.js, line 43 totalCount :number Total number of Resources in the catalogue matching our criteria Type: number Source: resource_collection.js, line 126 Methods add(data) Add a Resource to the local collection Note: this method does not implement any uniqueness constraints on the refs of objects/Resources being added. If this is required, use ResourceCollection#findOrCreate Parameters: Name Type Description data Object | Resource Can be either an existing Resource or a JSON object to create a new Resource from Source: resource_collection.js, line 361 See: ResourcefulEndpoint#newResource Returns: Type Resource destroy() Destroy (DELETE) all the Resources in this ResourceCollection. If the ResourceCollection has more items than the batchSize specified in the descriptor, multiple calls will be made to the backend Source: resource_collection.js, line 340 See: ResourceCollection#explode ResourcefulEndpoint#destroy Returns: Type Promise Example Destroy all content that went out of availability this year contents.all(where(field(&quot;availabilityEndAt&quot;).lessThan(&quot;2017&quot;))).then(resources =&gt; resources.destroy()); explode( [size]) Get an array of ResourceCollections populated with a maximum of the size paramater Resources in each. Sequoia has limits to how many Resources can be saved at once. This method is used internally by ResourceCollection#save and ResourceCollection#destroy to send the right amount of data. Parameters: Name Type Argument Default Description size number &lt;optional&gt; ResourcefulEndpoint#batchSize The number of Resources to return in each ResourceCollection Source: resource_collection.js, line 273 See: ResourcefulEndpoint#all Returns: Type Array.&lt;ResourceCollection&gt; &lt;private&gt; fetch(newCriteria) Update the collection with new data from the server. This will also return the new ResourceCollection as a convenience. Parameters: Name Type Argument Description newCriteria string &lt;nullable&gt; query string criteria to send to ResourcefulEndpoint#browse Source: resource_collection.js, line 212 Returns: The new ResourceCollection just fetched Type Promise find(ref) Returns a Resource if it exists in the local collection with the supplied ref Parameters: Name Type Description ref string The ref of the resource to find Source: resource_collection.js, line 400 Returns: Type Resource findOrCreate(resource) Find a resource in the local collection or create (and add to the local collection) a Resource from the supplied object Parameters: Name Type Description resource Resource | Object the resource to find or create Source: resource_collection.js, line 412 Returns: Type Resource findWhere(criteria) Find a Resource in the local collection or null if not found Parameters: Name Type Description criteria Criteria See ResourceCollection#where Source: resource_collection.js, line 481 See: ResourceCollection#where Returns: Type Resource firstPage() Fetch the first page of results Source: resource_collection.js, line 171 See: ResourceCollection#fetch Returns: Type Promise getPage(pageNumber) Fetch a specific page of results Parameters: Name Type Description pageNumber number the number of the page to fetch Source: resource_collection.js, line 198 See: ResourceCollection#fetch To Do: Boundary checking? This could likely be easier to use with the initialCriteria Returns: Type Promise lastPage() Fetch the last page of results Source: resource_collection.js, line 182 See: ResourceCollection#fetch Returns: Type Promise nextPage() Fetch the next page of results Source: resource_collection.js, line 141 See: ResourceCollection#fetch Returns: Type Promise previousPage() Fetch the previous page of results Source: resource_collection.js, line 156 See: ResourceCollection#fetch Returns: Type Promise remove(ref) Remove a Resource from the local collection Will return the found Resource or null if it does not exist Parameters: Name Type Description ref string the ref of the resource to remove Source: resource_collection.js, line 381 Returns: Type Resource save() Save (create or update) (POST/PUT) all the Resources in this ResourceCollection. If the ResourceCollection has more items than the batchSize specified in the descriptor, multiple calls will be made to the backend Source: resource_collection.js, line 293 See: ResourceCollection#explode ResourcefulEndpoint#store Returns: Type Promise serialise() Get a stringified version of this ResourceCollection that is suitable for saving to sequoia. Simply wraps the JSON of the resource collection as an array in the [] property Source: resource_collection.js, line 253 Returns: Type string &lt;private&gt; setData(rawData) Updates rawData with the json returned from the Sequoia service and sets collection to an array of `Resources Linked resources are collated into the individual Resources created for each item in the collection if they have relationship info. e.g. Assets that are linked to Contents will have a contentRef - if this is present, each Content instance will have a linked.assets[] with only the related Assets If there is no relationship specified in linked resources, (e.g. linked Customers against Subscriptions from the Payment service) then each Subscription instance will have all of the Customers avaliable as linked.customers[] Parameters: Name Type Description rawData Object json from a Sequoia browse request Source: resource_collection.js, line 69 Returns: self Type ResourceCollection toJSON() Get a JSON representation of this collection's keys/values Source: resource_collection.js, line 241 Returns: Type Object validate() Validate all the Resources in this collection. Source: resource_collection.js, line 323 See: Resource#validateField Returns: Type Promise Example resourceCollection.validate().catch((resource) =&gt; { // Show resource.errors[] }).then(resourceCollection =&gt; resourceCollection.save()) .then(() =&gt; { // do something on successfully saving }); where(criteria) Find a Resource in the local collection or null if not found The below examples assume the variable contents is populated with the result of client.service('metadata').then(s =&gt; s.resourcefulEndpoint('contents').all()) Parameters: Name Type Description criteria Criteria The criteria to use for filtering the local collection Source: resource_collection.js, line 447 See: ResourceCollection#where Returns: Type Array.&lt;Resource&gt; Examples Find all with a custom filter function // Find all of the Resources that have a title including 'die hard' that haven't had any tags applied yet contents.where(r =&gt; r.title.toLowerCase().includes('die hard') &amp;&amp; !Array.isArray(r.tags)) Find all that match a given object // Find all of the Resources that are active and have a type of 'show' contents.where({ type: 'show', active: true }) × Search results Close "},"ResourcefulEndpoint.html":{"id":"ResourcefulEndpoint.html","title":"Class: ResourcefulEndpoint","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: ResourcefulEndpoint ResourcefulEndpoint ResourceFulEndpoint is the main interaction class against sequoia MDS endpoints. This is what you'll be using to present data to users, for example content items, registered users etc. This class should not be used directly, but should instead be obtained from Service#resourcefulEndpoint &lt;private&gt; new ResourcefulEndpoint(transport, resourceful) Parameters: Name Type Description transport Transport Transport instance to use for fetching resourceful Object JSON object describing this resourceful endpoint (fetched from sequoia services 'descriptor') Source: resourceful_endpoint.js, line 32 Example // `contents` is used in the rest of the examples as our reference // to a ResourcefulEndpoint let contents; client.login('username', 'password').then(session =&gt; { client.service('metadata').then(service =&gt; { // Get a resourceful endpoint (this is synchronous as the service passed // all the necessary data): contents = service.resourcefulEndpoint('contents'); // whatever }); }); Members batchSize :number Get the batchSize from the descriptor's storeBatch operation. This is how many resources can be saved at once when saving a ResourceCollection Type: number Source: resourceful_endpoint.js, line 488 hyphenatedPluralName :string Get the hyphenatedPluralName from the descriptor. The hyphenated plural name is used to identify what the resourceful endpoint is called. e.g. a camelCased resource (pluralName) like contentSegments will live under an HTTP endpoint of content-segments Type: string Source: resourceful_endpoint.js, line 469 pluralName :string Get the pluralName from the descriptor. The plural name is used to identify the content array from the JSON response from Sequoia. e.g. for assets, the response will be of the form: { assets: [ asset resource, asset resource ... ], linked: [ linked resource, linked resource ... ], meta: { ...meta info } } Type: string Source: resourceful_endpoint.js, line 447 relationships :object Get the relationship info from the descriptor. Type: object Source: resourceful_endpoint.js, line 428 Example contents.relationships // Returns: { &quot;children&quot;: { &quot;description&quot;: &quot;The associated child contents&quot;, &quot;type&quot;: &quot;indirect&quot;, &quot;resourceType&quot;: &quot;contents&quot;, &quot;filterName&quot;: &quot;withParentRef&quot;, &quot;fields&quot;: [ &quot;ref&quot;, &quot;title&quot;, &quot;parentRef&quot;, &quot;type&quot; ], &quot;batchSize&quot;: 10, &quot;name&quot;: &quot;children&quot; }, &quot;assets&quot;: { &quot;description&quot;: &quot;The associated assets&quot;, &quot;type&quot;: &quot;indirect&quot;, &quot;resourceType&quot;: &quot;assets&quot;, &quot;filterName&quot;: &quot;withContentRef&quot;, &quot;fields&quot;: [ &quot;ref&quot;, &quot;name&quot;, &quot;contentRef&quot;, &quot;mediaType&quot;, &quot;url&quot;, &quot;fileFormat&quot;, &quot;title&quot;, &quot;fileSize&quot;, &quot;tags&quot; ], &quot;batchSize&quot;: 10, &quot;name&quot;: &quot;assets&quot; } } serviceName :string Get the serviceName from the descriptor. Type: string Source: resourceful_endpoint.js, line 478 singularName :string Get the singularName from the descriptor. The singular name is used to identify what the specific resourceful resource is identified as. Type: string Source: resourceful_endpoint.js, line 457 Methods all(criteria, options) The same as ResourcefulEndpoint#browse but will fetch all pages as a single ResourceCollection Parameters: Name Type Description criteria string | Query A query string to append to the request options object fetch options Source: resourceful_endpoint.js, line 216 See: Transport#get Returns: A ResourceCollection Type Promise browse(criteria, options) Perform a browse (a GET for all items on this resourceful endpoint, with optional criteria). The collection returned is the first page of results as specified by perPage (or the Resourceful default e.g. 100) Parameters: Name Type Description criteria string | Query A query string to append to the request options object fetch options Source: resourceful_endpoint.js, line 201 See: Trasport#get Returns: A ResourceCollection Type Promise &lt;private&gt; criteriaToQuery(criteria) Return a query string to append to the HTTP call. Will default to appending ?owner=&lt;owner&gt; Parameters: Name Type Argument Description criteria string | Query &lt;nullable&gt; A (potential) query string to append to the request Source: resourceful_endpoint.js, line 511 Returns: Type string destroy(resource, options) Destroy (perform an HTTP DELETE for) an existing item Parameters: Name Type Description resource Object An Object corresponding to the resouce you wish to delete options object fetch options Source: resourceful_endpoint.js, line 330 See: Transport#destroy Returns: Type Promise &lt;private&gt; endPointUrl(ref, criteria) Get the full URL to the resourceful endpoint/item we will send the request to Parameters: Name Type Argument Description ref string &lt;nullable&gt; An optional unique ref for performing actions on a unique item (rather than browsing) criteria string | Query &lt;nullable&gt; A (potential) query string to append to the request Source: resourceful_endpoint.js, line 537 See: ResourcefulEndpoint#criteriaToQuery Returns: Type string newResource(data) Obtain a new Resource for this endpoint. A new resource is something that has not yet been created remotely. The owner property will be pre-populated with the current tenancy. Provding a a value for this will override the current tenancy. This is useful when using root tenancy but populating data on behalf of non-root tenancies. See Client#setTenancy for more information. When a name property is provided, the ref (unique id) of this resource will also be populated. This is useful for allowing linking different kinds of resources together (see Resource#link) before saving the resources. There is a potential that names you choose will conflict with already stored resources. In this case, your changes will override the remote resource. See the below example for how to handle these situations. Parameters: Name Type Description data Object data to populate the Resource with Properties Name Type Argument Description owner string &lt;optional&gt; Defaults to the current tenancy name Source: resourceful_endpoint.js, line 145 Returns: Type Resource Examples Create a new resource const contentItem = contents.newResource({ name: 'my-new-content', title: 'something', synopsis: 'a really long synopsis' }); // You can now call methods on it, for example, a usual flow for creating // a Resource would be: contentItem.validate() .then(() =&gt; contentItem.save()) .then(() =&gt; { // Success, do something (redirect to a new view?) }).catch((error) =&gt; { // Validation error (from Resource object or the server), show the user what went wrong }); Update or create a piece of content const potentiallyNewContentItem = contents.newResource({ name: 'my-potentially-new-content', title: 'something new', synopsis: 'a really long synopsis' }); function findOrCreateResource(resourceful, data) { return resourceful.readOne(`${resourceful.owner}:${data.name}`).catch(() =&gt; resourceful.newResource(data)); } // You can now call methods on it, for example, a usual flow for creating // a Resource would be: findOrCreateResource(contents, potentiallyNewContentItem) .then((contentItem) =&gt; { // Update with new data in case it was an existing resource Object.assign(contentItem, potentiallyNewContentItem); contentItem.duration = 'PT75M'; return contentItem.save()) .then(() =&gt; { // Success, do something (redirect to a new view?) }).catch((error) =&gt; { // Validation error (from the server), show the user what went wrong }); newResourceCollection(data) Create a new ResourceCollection for this endpoint. Useful for creating many resources for ingest. Parameters: Name Type Description data Array.&lt;Object&gt; data to populate the ResourceCollection with Source: resourceful_endpoint.js, line 185 Returns: Type ResourceCollection Example Create a new resource const contentItems = contents.newResourceCollection([{ name: 'one', title: 'something', synopsis: 'a really long synopsis' }, { name: 'two', title: 'something else', synopsis: 'another really long synopsis' }]); contentItems.validate() .then(() =&gt; contentItems.save()) .then(() =&gt; { // Success, do something (redirect to a new view?) }).catch((error) =&gt; { // Validation error (from a nested Resource object or the server), show the user what went wrong }); readMany(refs, criteria, options) Fetch (performs an HTTP GET on) many items, with optional criteria Parameters: Name Type Description refs Array.&lt;String&gt; The unique references for the items criteria string | Query A query string to append to the request options object fetch options Source: resourceful_endpoint.js, line 280 See: Transport#get Returns: A ResourceCollection Type Promise readOne(ref, criteria, options) Fetch (performs an HTTP GET on) an individual item, with optional criteria Parameters: Name Type Description ref string The unique reference for this item criteria string | Query A query string to append to the request options object fetch options Source: resourceful_endpoint.js, line 265 See: Transport#get Returns: A Resource Type Promise relationshipFor(relationshipName) Get the relationship info for relationshipName from the descriptor Parameters: Name Type Description relationshipName string The name of the relationship e.g. 'assets' Source: resourceful_endpoint.js, line 371 Throws: Throws when the relationship doesn't exist Type Error Returns: Type Object Example contents.relationshipFor('categories'); // Returns: { &quot;description&quot;: &quot;The associated categories&quot;, &quot;type&quot;: &quot;direct&quot;, &quot;resourceType&quot;: &quot;categories&quot;, &quot;fieldNamePath&quot;: &quot;categoryRefs&quot;, &quot;fields&quot;: [ &quot;ref&quot;, &quot;title&quot;, &quot;parentRef&quot;, &quot;scheme&quot;, &quot;value&quot; ], &quot;name&quot;: &quot;categories&quot;, &quot;batchSize&quot;: 10 } &lt;private&gt; responseToResource() Turn the first item in the Sequoia response for this endpoint into a Resource. This is a convenience for when operating on individual Resources (read, update, store) where the sequoia response is of the form { &lt;pluralName&gt;: [&lt;Resource&gt;], meta: { ... } }and we want to just operate on Resource Source: resourceful_endpoint.js, line 69 Returns: Type Resource store(resource, options) Store (perform an HTTP POST for) a new item Parameters: Name Type Description resource Resource A Resource corresponding to the new resource you wish to save options object fetch options Source: resourceful_endpoint.js, line 296 See: Transport#post To Do: Validate against the descriptor that this is a valid item to store Returns: Type Promise update(resource, options) Update (perform an HTTP PUT for) an existing item Parameters: Name Type Description resource Object An Object corresponding to the new resouce you wish to save options object fetch options Source: resourceful_endpoint.js, line 314 See: Transport#put To Do: Validate against the descriptor that this is a valid item to store Returns: Type Promise × Search results Close "},"Service.html":{"id":"Service.html","title":"Class: Service","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Service Service Provides details of a Sequoia Service This class should not be used directly, but should instead be obtained from Client#service &lt;private&gt; new Service(transport, data) Parameters: Name Type Description transport Transport Transport instance to use for fetching data Object JSON data returned from the service's raw description e.g. https://metadata-sandbox.sequoia.piksel.com/descriptor/raw?owner=demo Properties: Name Type Description data Object JSON data returned from the service's raw description e.g. https://metadata-sandbox.sequoia.piksel.com/descriptor/raw?owner=demo Source: registry.js, line 19 Methods businessEndpoint(name) Get a BusinessEndpoint from a Service Parameters: Name Type Description name string e.g. 'feeds' (the feeds business endpoint from the gateway service) Source: registry.js, line 70 Returns: Type BusinessEndpoint resourcefulEndpoint(resourceName) Get a ResourcefulEndpoint from a Service Parameters: Name Type Description resourceName string e.g. 'contents' (the contents resourceful endpoint from the meatatdata service) Source: registry.js, line 33 Returns: Type ResourcefulEndpoint resourcefulEndpoints(resourceName) Get an array of ResourcefulEndpoints from a Service Parameters: Name Type Argument Description resourceName string &lt;repeatable&gt; e.g. 'assets', 'contents' (the assets and contents resourceful endpoint from the meatatdata service) Source: registry.js, line 56 Returns: Type Array.&lt;ResourcefulEndpoint&gt; Example const [ assets, contents ] = service.resourcefulEndpoints('assets', 'contents'); resourcefuls() Get the list of resourcefuls for this Service Source: registry.js, line 93 To Do: This method isn't used and also does not return an array - it is not advised to use yet Should this return an array of ResourcefulEndpoints instead? Returns: a list of resourcefuls populated from the descriptor Type Array.&lt;Object&gt; × Search results Close "},"Session.html":{"id":"Session.html","title":"Class: Session","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Session Session Manages the end user authentication session against (currently) pauth token. This class is not intended to be used directly. You should instead use Client#login, Client#logout and Client's session property See the Sequoia Documentation for more information. new Session(transport, directory, registry, identityUri) Parameters: Name Type Argument Description transport Transport Transport instance to use for fetching directory string The directory (sometimes refered to as 'domain') that the user belongs to. This is prepended to the username on login requests (POSTs to /pauth/token) registry Registry a stored registry reference to query identityUri string &lt;nullable&gt; The endpoint URI for the sequoia identity service e.g. https://identity-sandbox.sequoia.piksel.com Properties: Name Type Argument Description directory string Stored from the initial directory parameter identityUri string &lt;nullable&gt; Stored from the initial identityUri parameter token string &lt;nullable&gt; The access_token returned from the call to /pauth/token after logging in tenants Array.&lt;Object&gt; Stored array of tenants the user has access to See the tenants documentation for more information. access Object Stored access information for the logged in user. See the access documentation for more information. Source: session.js, line 39 Example import Session from '@pikselpalette/sequoia-js-client-sdk/lib/session'; const session = new Session('piksel', 'https://identity-sandbox.sequoia.piksel.com'); session.authenticateWithCredentials('username', 'password').then((session) =&gt; this.registry.fetch(session.currentOwner())).then(() =&gt; this.session) Members &lt;nullable&gt; currentTenant :string The current tenant being used in this session. When getting this propery, it will default to the first tenant in the Session.tenants array if this property has not been explicitly set Will return null if there are no tenants available (e.g. the session is inactive) Type: string Source: session.js, line 298 Methods authenticateWithCredentials(username, password, options) Create a session based on end user credentials Parameters: Name Type Argument Description username string &lt;nullable&gt; password string &lt;nullable&gt; options AuthenticationOptions &lt;nullable&gt; Source: session.js, line 92 See: {Client#login} Returns: Type Promise authenticateWithToken(token) Create a session based on an existing bearer token Use this if you acquire an access token via other means, i.e. an existing oauth mechanism for Sequoia Parameters: Name Type Description token string Source: session.js, line 154 Returns: Type Promise clearExpiryWarning() Clear the expiry warning callback and cancel any timers. Source: session.js, line 189 currentOwner() Get the name (owner) of the current tenant Source: session.js, line 315 Returns: Type string destroy() Log out an end user Source: session.js, line 326 To Do: Should this make a call to some service to revoke the auth token? Returns: Type Session findTenant() Find a tenant by name in the current set of user available tenants Source: session.js, line 285 Returns: Type Object isActive() Returns whether there is a currently active logged in session Source: session.js, line 276 Returns: Type boolean &lt;private&gt; populateAccess() Populate the access properties of Session with data returned from Sequoia. Source: session.js, line 250 Returns: Type Promise &lt;private&gt; populateTenants() Populate the tenants properties of Session with data returned from Sequoia. Source: session.js, line 229 Returns: Type Promise setOnExpiryWarning(callback, threshold) Set the expiry warning callback and threshold. Parameters: Name Type Argument Default Description callback function &lt;nullable&gt; Callback invoked when token is expiring threshold Number &lt;nullable&gt; 60000 Threshold before expiry on which to invoke the callback, default 60000ms Source: session.js, line 175 startOnExpiryWarningTimer() Start the expiry warning timer. Source: session.js, line 203 tokenExpiring(access) Called when the token is about to expire. Calls the callback if registered. Parameters: Name Type Description access AccessSession The Sequoia access session Source: session.js, line 215 × Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Class: Transport Transport Handles fetching. This class should not be used directly, but should instead be obtained from Service#resourcefulEndpoint or Service#businessEndpoint new Transport(options) Parameters: Name Type Argument Description options TransportDefaults &lt;nullable&gt; The options to use with all fetch requests Properties: Name Type Argument Description defaults TransportDefaults &lt;nullable&gt; Stored from the initial 'options' parameter merged with the standard defaults Source: transport.js, line 18 Example import Transport from '@pikselpalette/sequoia-js-client-sdk/lib/transport'; const transport = new Transport({method: 'POST'}); transport.fetchWithDefaults('someurl').then((response) =&gt; console.log(response); Methods destroy(url, options) Performs an HTTP DELETE request Parameters: Name Type Description url string sequoia url options object fetch options Source: transport.js, line 110 Returns: Type Promise fetchWithDefaults(url, options) Performs a fetch with the default options from Transport Parameters: Name Type Description url string sequoia url options object fetch options Source: transport.js, line 50 Returns: Type Promise get(url, options) Performs an HTTP GET request Parameters: Name Type Description url string sequoia url options object fetch options Source: transport.js, line 74 Returns: Type Promise post(url, options) Performs an HTTP POST request Parameters: Name Type Description url string sequoia url options object fetch options Source: transport.js, line 86 Returns: Type Promise put(url, options) Performs an HTTP PUT request Parameters: Name Type Description url string sequoia url options object fetch options Source: transport.js, line 98 Returns: Type Promise × Search results Close "},"tutorial-getting_started.html":{"id":"tutorial-getting_started.html","title":"Tutorial: Getting Started","body":" Javascript Client SDK Classes BusinessEndpointClientPredicationsQueryRegistryResourceResourceCollectionResourcefulEndpointServiceSessionTransport Tutorials Getting Started Global ValidationError Getting Started Getting startedInstallationnpm install --save @pikselpalette/sequoia-js-client-sdkBasic Usage (get some filtered contents)In es6 module loader environments (webpack, rollup, browserify etc)import Client from '@pikselpalette/sequoia-js-client-sdk/lib/client'; import { where, field } from '@pikselpalette/sequoia-js-client-sdk/lib/query'; // Create a client: const client = new Client({ directory: 'piksel', registryUri: 'https://identity-sandbox.sequoia.piksel.com' }); client .login('username', 'password') .then(session =&gt; { // You can now query the session provided as the first argument (or // client.session); e.g. `session.isActive()` // Get a service:: client.service('metadata').then(service =&gt; { // Get a resourceful endpoint (this is synchronous as the service passed // all the necessary data): const contents = service.resourcefulEndpoint('contents'); contents .browse( where() .fields('title', 'mediumSynopsis', 'duration', 'ref') .include('assets') .page(1) .perPage(24) .orderByUpdatedAt() .desc() .count() ) .then(collection =&gt; { // Do something with the ResourceCollection returned }); }); }) .catch(error =&gt; { // Not logged in, inspect `error` to see why });In non-es6 module loader environments (e.g. node)// Use e.g. #!/usr/bin/env node --harmony_async_await require('isomorphic-fetch'); const Client = require('@pikselpalette/sequoia-js-client-sdk/dist/sequoia-client.js'); const { where, field, param, textSearch } = Client; // Create a client: const client = new Client({ directory: 'piksel', registryUri: 'https://identity-sandbox.sequoia.piksel.com' }); (async function init() { await client.generate(bearerToken); const service = await client.service('metadata'); const contents = service.resourcefulEndpoint('contents'); const collection = await contents.browse( where() .fields('title', 'mediumSynopsis', 'duration', 'ref') .include('assets') .page(1) .perPage(24) .orderByUpdatedAt() .desc() .count() ); // Do something with the ResourceCollection returned })(); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
